============================= test session starts ==============================
platform linux -- Python 3.10.11, pytest-8.3.5, pluggy-1.5.0
rootdir: /home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified
configfile: pyproject.toml
plugins: anyio-4.9.0, metadata-3.1.1, json-report-1.5.0, cov-6.1.1
collected 194 items

tests/digital_artist/test_asset_tracker.py F....                         [  2%]
tests/digital_artist/test_backup_engine.py FFF..F                        [  5%]
tests/digital_artist/test_element_extraction.py ........                 [  9%]
tests/digital_artist/test_integration.py FF..F                           [ 12%]
tests/digital_artist/test_timeline_manager.py FFFFF                      [ 14%]
tests/digital_artist/test_visual_diff.py .......                         [ 18%]
tests/digital_artist/test_workspace_capture.py ......                    [ 21%]
tests/game_developer/asset_optimization/test_chunking.py ......F         [ 25%]
tests/game_developer/asset_optimization/test_compressor.py FFFF.FF       [ 28%]
tests/game_developer/asset_optimization/test_deduplication.py .......    [ 32%]
tests/game_developer/asset_optimization/test_manager.py FFFFFFFF         [ 36%]
tests/game_developer/backup_engine/test_chunking.py .....                [ 39%]
tests/game_developer/backup_engine/test_engine.py FFFFFF                 [ 42%]
tests/game_developer/backup_engine/test_storage.py FFFFFF..F             [ 46%]
tests/game_developer/backup_engine/test_version_tracker.py EEEEEEEEE.    [ 52%]
tests/game_developer/feedback_system/test_analysis.py .......            [ 55%]
tests/game_developer/feedback_system/test_database.py ........           [ 59%]
tests/game_developer/feedback_system/test_manager.py ............        [ 65%]
tests/game_developer/integration/test_game_development_workflow.py EEEE  [ 68%]
tests/game_developer/milestone_management/test_manager.py .............  [ 74%]
tests/game_developer/performance/test_backup_performance.py sssssss      [ 78%]
tests/game_developer/performance/test_playtest_performance.py sssss      [ 80%]
tests/game_developer/platform_config/test_manager.py ...........         [ 86%]
tests/game_developer/playtest_recorder/test_analysis.py ........         [ 90%]
tests/game_developer/playtest_recorder/test_recorder.py ....F....        [ 95%]
tests/game_developer/playtest_recorder/test_storage.py ...F.F...         [100%]

==================================== ERRORS ====================================
____________________ ERROR at setup of test_create_version _____________________

    @pytest.fixture
    def sample_files():
        """Create sample file info for testing."""
        return {
>           "file1.txt": FileInfo(
                path="file1.txt",
                size=100,
                hash="hash1",
                modified_time=1000.0,
                is_binary=False,
                storage_path="/path/to/file1.txt"
            ),
            "file2.bin": FileInfo(
                path="file2.bin",
                size=200,
                hash="hash2",
                modified_time=1001.0,
                is_binary=True,
                chunks=["chunk1", "chunk2"]
            ),
            "file3.png": FileInfo(
                path="file3.png",
                size=300,
                hash="hash3",
                modified_time=1002.0,
                is_binary=True,
                chunks=["chunk3", "chunk4"]
            )
        }
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/backup_engine/test_version_tracker.py:27: TypeError
______________ ERROR at setup of test_create_version_with_parent _______________

    @pytest.fixture
    def sample_files():
        """Create sample file info for testing."""
        return {
>           "file1.txt": FileInfo(
                path="file1.txt",
                size=100,
                hash="hash1",
                modified_time=1000.0,
                is_binary=False,
                storage_path="/path/to/file1.txt"
            ),
            "file2.bin": FileInfo(
                path="file2.bin",
                size=200,
                hash="hash2",
                modified_time=1001.0,
                is_binary=True,
                chunks=["chunk1", "chunk2"]
            ),
            "file3.png": FileInfo(
                path="file3.png",
                size=300,
                hash="hash3",
                modified_time=1002.0,
                is_binary=True,
                chunks=["chunk3", "chunk4"]
            )
        }
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/backup_engine/test_version_tracker.py:27: TypeError
______________________ ERROR at setup of test_get_version ______________________

    @pytest.fixture
    def sample_files():
        """Create sample file info for testing."""
        return {
>           "file1.txt": FileInfo(
                path="file1.txt",
                size=100,
                hash="hash1",
                modified_time=1000.0,
                is_binary=False,
                storage_path="/path/to/file1.txt"
            ),
            "file2.bin": FileInfo(
                path="file2.bin",
                size=200,
                hash="hash2",
                modified_time=1001.0,
                is_binary=True,
                chunks=["chunk1", "chunk2"]
            ),
            "file3.png": FileInfo(
                path="file3.png",
                size=300,
                hash="hash3",
                modified_time=1002.0,
                is_binary=True,
                chunks=["chunk3", "chunk4"]
            )
        }
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/backup_engine/test_version_tracker.py:27: TypeError
_____________________ ERROR at setup of test_list_versions _____________________

    @pytest.fixture
    def sample_files():
        """Create sample file info for testing."""
        return {
>           "file1.txt": FileInfo(
                path="file1.txt",
                size=100,
                hash="hash1",
                modified_time=1000.0,
                is_binary=False,
                storage_path="/path/to/file1.txt"
            ),
            "file2.bin": FileInfo(
                path="file2.bin",
                size=200,
                hash="hash2",
                modified_time=1001.0,
                is_binary=True,
                chunks=["chunk1", "chunk2"]
            ),
            "file3.png": FileInfo(
                path="file3.png",
                size=300,
                hash="hash3",
                modified_time=1002.0,
                is_binary=True,
                chunks=["chunk3", "chunk4"]
            )
        }
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/backup_engine/test_version_tracker.py:27: TypeError
__________________ ERROR at setup of test_get_version_history __________________

    @pytest.fixture
    def sample_files():
        """Create sample file info for testing."""
        return {
>           "file1.txt": FileInfo(
                path="file1.txt",
                size=100,
                hash="hash1",
                modified_time=1000.0,
                is_binary=False,
                storage_path="/path/to/file1.txt"
            ),
            "file2.bin": FileInfo(
                path="file2.bin",
                size=200,
                hash="hash2",
                modified_time=1001.0,
                is_binary=True,
                chunks=["chunk1", "chunk2"]
            ),
            "file3.png": FileInfo(
                path="file3.png",
                size=300,
                hash="hash3",
                modified_time=1002.0,
                is_binary=True,
                chunks=["chunk3", "chunk4"]
            )
        }
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/backup_engine/test_version_tracker.py:27: TypeError
____________________ ERROR at setup of test_get_milestones _____________________

    @pytest.fixture
    def sample_files():
        """Create sample file info for testing."""
        return {
>           "file1.txt": FileInfo(
                path="file1.txt",
                size=100,
                hash="hash1",
                modified_time=1000.0,
                is_binary=False,
                storage_path="/path/to/file1.txt"
            ),
            "file2.bin": FileInfo(
                path="file2.bin",
                size=200,
                hash="hash2",
                modified_time=1001.0,
                is_binary=True,
                chunks=["chunk1", "chunk2"]
            ),
            "file3.png": FileInfo(
                path="file3.png",
                size=300,
                hash="hash3",
                modified_time=1002.0,
                is_binary=True,
                chunks=["chunk3", "chunk4"]
            )
        }
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/backup_engine/test_version_tracker.py:27: TypeError
__________________ ERROR at setup of test_get_versions_by_tag __________________

    @pytest.fixture
    def sample_files():
        """Create sample file info for testing."""
        return {
>           "file1.txt": FileInfo(
                path="file1.txt",
                size=100,
                hash="hash1",
                modified_time=1000.0,
                is_binary=False,
                storage_path="/path/to/file1.txt"
            ),
            "file2.bin": FileInfo(
                path="file2.bin",
                size=200,
                hash="hash2",
                modified_time=1001.0,
                is_binary=True,
                chunks=["chunk1", "chunk2"]
            ),
            "file3.png": FileInfo(
                path="file3.png",
                size=300,
                hash="hash3",
                modified_time=1002.0,
                is_binary=True,
                chunks=["chunk3", "chunk4"]
            )
        }
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/backup_engine/test_version_tracker.py:27: TypeError
_________________ ERROR at setup of test_get_versions_by_type __________________

    @pytest.fixture
    def sample_files():
        """Create sample file info for testing."""
        return {
>           "file1.txt": FileInfo(
                path="file1.txt",
                size=100,
                hash="hash1",
                modified_time=1000.0,
                is_binary=False,
                storage_path="/path/to/file1.txt"
            ),
            "file2.bin": FileInfo(
                path="file2.bin",
                size=200,
                hash="hash2",
                modified_time=1001.0,
                is_binary=True,
                chunks=["chunk1", "chunk2"]
            ),
            "file3.png": FileInfo(
                path="file3.png",
                size=300,
                hash="hash3",
                modified_time=1002.0,
                is_binary=True,
                chunks=["chunk3", "chunk4"]
            )
        }
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/backup_engine/test_version_tracker.py:27: TypeError
____________________ ERROR at setup of test_delete_version _____________________

    @pytest.fixture
    def sample_files():
        """Create sample file info for testing."""
        return {
>           "file1.txt": FileInfo(
                path="file1.txt",
                size=100,
                hash="hash1",
                modified_time=1000.0,
                is_binary=False,
                storage_path="/path/to/file1.txt"
            ),
            "file2.bin": FileInfo(
                path="file2.bin",
                size=200,
                hash="hash2",
                modified_time=1001.0,
                is_binary=True,
                chunks=["chunk1", "chunk2"]
            ),
            "file3.png": FileInfo(
                path="file3.png",
                size=300,
                hash="hash3",
                modified_time=1002.0,
                is_binary=True,
                chunks=["chunk3", "chunk4"]
            )
        }
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/backup_engine/test_version_tracker.py:27: TypeError
____________ ERROR at setup of test_complete_game_development_cycle ____________

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e841e70>

    @pytest.fixture
    def feedback_manager(backup_engine):
        """Create a feedback manager instance."""
        return FeedbackManager(
            project_name="test_game",
            version_tracker=backup_engine.version_tracker,
>           storage_dir=backup_engine.storage_dir
        )
E       AttributeError: 'BackupEngine' object has no attribute 'storage_dir'

tests/game_developer/integration/test_game_development_workflow.py:79: AttributeError
_________________ ERROR at setup of test_milestone_annotations _________________

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e8418d0>

    @pytest.fixture
    def milestone_manager(backup_engine):
        """Create a milestone manager instance."""
        return MilestoneManager(
            project_name="test_game",
            backup_engine=backup_engine,
>           storage_dir=backup_engine.storage_dir
        )
E       AttributeError: 'BackupEngine' object has no attribute 'storage_dir'

tests/game_developer/integration/test_game_development_workflow.py:89: AttributeError
______________ ERROR at setup of test_platform_specific_features _______________

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e855cc0>

    @pytest.fixture
    def platform_config_manager(backup_engine):
        """Create a platform configuration manager instance."""
        return PlatformConfigManager(
            project_name="test_game",
>           storage_dir=backup_engine.storage_dir
        )
E       AttributeError: 'BackupEngine' object has no attribute 'storage_dir'

tests/game_developer/integration/test_game_development_workflow.py:98: AttributeError
_______ ERROR at setup of test_configuration_management_across_platforms _______

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e9376d0>

    @pytest.fixture
    def platform_config_manager(backup_engine):
        """Create a platform configuration manager instance."""
        return PlatformConfigManager(
            project_name="test_game",
>           storage_dir=backup_engine.storage_dir
        )
E       AttributeError: 'BackupEngine' object has no attribute 'storage_dir'

tests/game_developer/integration/test_game_development_workflow.py:98: AttributeError
=================================== FAILURES ===================================
______________________________ test_scan_project _______________________________

asset_tracker = <creative_vault.asset_tracker.reference_tracker.CreativeAssetReferenceTracker object at 0x7f974ea21840>
test_project_dir = PosixPath('/tmp/tmpjzqhtm3p/test_project')

    def test_scan_project(asset_tracker, test_project_dir):
        """Test scanning a project to identify assets and references."""
        # Scan the project
        result = asset_tracker.scan_project(test_project_dir)
    
        # Check the result
        assert result is not None
>       assert "project_path" in result
E       TypeError: argument of type 'ReferenceMap' is not iterable

tests/digital_artist/test_asset_tracker.py:21: TypeError
__________________________ test_initialize_repository __________________________

temp_dir = PosixPath('/tmp/tmpwdg7yo3h')

    def test_initialize_repository(temp_dir):
        """Test initializing a new backup repository."""
        # Create a backup engine
        repo_path = temp_dir / "test_repo"
        config = BackupConfig(repository_path=repo_path)
        engine = DeltaBackupEngine(config)
    
        # Initialize the repository
        result = engine.initialize_repository(repo_path)
    
        # Check the result
>       assert result is True
E       assert False is True

tests/digital_artist/test_backup_engine.py:26: AssertionError
----------------------------- Captured stdout call -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
_____________________________ test_create_snapshot _____________________________

backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e963430>
test_project_dir = PosixPath('/tmp/tmpnxn15u70/test_project')

    def test_create_snapshot(backup_engine, test_project_dir):
        """Test creating a snapshot of a project directory."""
        # Create a snapshot
        snapshot_id = backup_engine.create_snapshot(test_project_dir)
    
        # Check that the snapshot was created
        assert snapshot_id is not None
>       assert snapshot_id.startswith("snapshot-")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x7f974e939110>('snapshot-')
E        +    where <built-in method startswith of str object at 0x7f974e939110> = 'snapshot_20250616_042717_819325'.startswith

tests/digital_artist/test_backup_engine.py:43: AssertionError
---------------------------- Captured stdout setup -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
____________________________ test_restore_snapshot _____________________________

backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e936260>
test_project_dir = PosixPath('/tmp/tmprp6t4yj4/test_project')
temp_dir = PosixPath('/tmp/tmprp6t4yj4')

    def test_restore_snapshot(backup_engine, test_project_dir, temp_dir):
        """Test restoring a snapshot to a directory."""
        # Create a snapshot
        snapshot_id = backup_engine.create_snapshot(test_project_dir)
    
        # Create a target directory for restoration
        target_dir = temp_dir / "restored_project"
    
        # Restore the snapshot
        result = backup_engine.restore_snapshot(snapshot_id, target_dir)
    
        # Check the result
>       assert result is True
E       assert False is True

tests/digital_artist/test_backup_engine.py:65: AssertionError
---------------------------- Captured stdout setup -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
----------------------------- Captured stdout call -----------------------------
Error restoring snapshot snapshot_20250616_042717_833757: Failed to restore snapshot snapshot_20250616_042717_833757: 'dict' object has no attribute 'files'
___________________________ test_incremental_backup ____________________________

backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e960c10>
test_project_dir = PosixPath('/tmp/tmpqxx3tvhy/test_project')

    def test_incremental_backup(backup_engine, test_project_dir):
        """Test incremental backup with modified files."""
        # Create an initial snapshot
        snapshot_id_1 = backup_engine.create_snapshot(test_project_dir)
    
        # Modify a file in the project
        with open(test_project_dir / "project.txt", "a") as f:
            f.write("This is a new line added to test incremental backup.\n")
    
        # Create a new file
        with open(test_project_dir / "new_file.txt", "w") as f:
            f.write("This is a new file added to test incremental backup.\n")
    
        # Create a second snapshot
        snapshot_id_2 = backup_engine.create_snapshot(test_project_dir)
    
        # Get info about the second snapshot
        snapshot_info = backup_engine.get_snapshot_info(snapshot_id_2)
    
        # Check that only the modified and new files are included
>       assert len(snapshot_info["new_files"]) == 1  # The new file
E       AssertionError: assert 6 == 1
E        +  where 6 = len(['/tmp/tmpqxx3tvhy/test_project/project.txt', '/tmp/tmpqxx3tvhy/test_project/new_file.txt', '/tmp/tmpqxx3tvhy/test_pro...es/texture1.png', '/tmp/tmpqxx3tvhy/test_project/images/image1.png', '/tmp/tmpqxx3tvhy/test_project/images/image2.png'])

tests/digital_artist/test_backup_engine.py:136: AssertionError
---------------------------- Captured stdout setup -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
----------------------------- Captured stdout call -----------------------------
Error reading unified snapshots: Failed to list snapshots: 'dict' object has no attribute 'timestamp'
______________________ test_full_backup_restore_workflow _______________________

temp_dir = PosixPath('/tmp/tmp2uyj30in')
test_project_dir = PosixPath('/tmp/tmp2uyj30in/test_project')

    def test_full_backup_restore_workflow(temp_dir, test_project_dir):
        """Test the complete backup and restore workflow."""
        # Initialize CreativeVault
        vault = CreativeVault(repository_path=temp_dir / "repo")
    
        # Create a backup of the test project
        backup_result = vault.backup_project(test_project_dir)
    
        # Check the backup result
        assert "snapshot_id" in backup_result
        snapshot_id = backup_result["snapshot_id"]
    
        # Create a target directory for restoration
        restore_dir = temp_dir / "restored_project"
    
        # Restore the backup
        restore_result = vault.restore_project(snapshot_id, restore_dir)
    
        # Check the restore result
>       assert restore_result["success"] is True
E       assert False is True

tests/digital_artist/test_integration.py:34: AssertionError
----------------------------- Captured stdout call -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
Error restoring snapshot snapshot_20250616_042717_906679: Failed to restore snapshot snapshot_20250616_042717_906679: 'dict' object has no attribute 'files'
_______________________ test_version_comparison_workflow _______________________

temp_dir = PosixPath('/tmp/tmpgj5ik7bk')
test_project_dir = PosixPath('/tmp/tmpgj5ik7bk/test_project')
test_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')
test_image_modified = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image_modified.png')

    def test_version_comparison_workflow(temp_dir, test_project_dir, test_image, test_image_modified):
        """Test the version comparison workflow."""
        # Initialize CreativeVault
        vault = CreativeVault(repository_path=temp_dir / "repo")
    
        # Create an image to track in the project directory
        image_path = test_project_dir / "images" / "test_comparison.png"
        shutil.copy(test_image, image_path)
    
        # Create an initial backup
        backup_result = vault.backup_project(test_project_dir)
        snapshot_id_1 = backup_result["snapshot_id"]
    
        # Initialize the timeline for an image file
        version_id_1 = vault.timeline_manager.register_version(image_path, snapshot_id_1)
    
        # Replace with the modified image instead of modifying at runtime
        shutil.copy(test_image_modified, image_path)
    
        # Create a second backup
        backup_result = vault.backup_project(test_project_dir)
        snapshot_id_2 = backup_result["snapshot_id"]
    
        # Register the second version
>       version_id_2 = vault.timeline_manager.register_version(image_path, snapshot_id_2)

tests/digital_artist/test_integration.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974eacf970>
file_path = PosixPath('/tmp/tmpgj5ik7bk/test_project/images/test_comparison.png')
snapshot_id = 'snapshot_20250616_042717_926705', metadata = None

    def register_version(
        self,
        file_path: Path,
        snapshot_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Register a new version of a file in the timeline.
    
        Args:
            file_path: Path to the file
            snapshot_id: ID of the snapshot containing this version
            metadata: Optional metadata about this version
    
        Returns:
            str: Unique version ID
    
        Raises:
            ValueError: If the snapshot does not exist
        """
        snapshot_path = self.snapshots_path / snapshot_id
        if not snapshot_path.exists():
            raise ValueError(f"Snapshot {snapshot_id} does not exist")
    
        # Create a unique version ID
        version_id = create_unique_id("ver-")
    
        # Get the snapshot manifest to find the file
        manifest_path = snapshot_path / "manifest.json"
        try:
            manifest = load_json(manifest_path)
        except Exception as e:
            raise ValueError(f"Failed to load snapshot manifest: {e}")
    
        # Try to find the file in the manifest using different path formats
        # First try the original path as-is
        relative_path = str(file_path)
        if relative_path not in manifest["files"]:
            # Try using just the filename
            file_name = file_path.name
            matching_paths = [path for path in manifest["files"].keys() if path.endswith(file_name)]
            if matching_paths:
                relative_path = matching_paths[0]
            else:
                # If still not found, fail with a clear error
>               raise ValueError(f"File {relative_path} not found in snapshot {snapshot_id}")
E               ValueError: File /tmp/tmpgj5ik7bk/test_project/images/test_comparison.png not found in snapshot snapshot_20250616_042717_926705

creative_vault/timeline/timeline_manager.py:107: ValueError
----------------------------- Captured stdout call -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
Warning: Failed to generate thumbnail for ver-1750048037926_927436: Object file not found for version ver-1750048037926_927436
Error reading unified snapshots: Failed to list snapshots: 'dict' object has no attribute 'timestamp'
_________________________ test_multi_snapshot_timeline _________________________

temp_dir = PosixPath('/tmp/tmpv8fq7507')
test_project_dir = PosixPath('/tmp/tmpv8fq7507/test_project')

    def test_multi_snapshot_timeline(temp_dir, test_project_dir):
        """Test creating multiple snapshots and tracking a file's timeline."""
        # Initialize CreativeVault
        vault = CreativeVault(repository_path=temp_dir / "repo")
    
        # Create a test image to track
        target_image = test_project_dir / "test_tracked_image.png"
    
        # Create the initial image
        img = Image.new('RGB', (200, 200), color=(0, 0, 255))
        img.save(target_image)
    
        # Create the first backup
        backup_result_1 = vault.backup_project(test_project_dir)
        snapshot_id_1 = backup_result_1["snapshot_id"]
    
        # Register the first version of a file
>       version_id_1 = vault.timeline_manager.register_version(target_image, snapshot_id_1)

tests/digital_artist/test_integration.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974eacdff0>
file_path = PosixPath('/tmp/tmpv8fq7507/test_project/test_tracked_image.png')
snapshot_id = 'snapshot_20250616_042717_969772', metadata = None

    def register_version(
        self,
        file_path: Path,
        snapshot_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Register a new version of a file in the timeline.
    
        Args:
            file_path: Path to the file
            snapshot_id: ID of the snapshot containing this version
            metadata: Optional metadata about this version
    
        Returns:
            str: Unique version ID
    
        Raises:
            ValueError: If the snapshot does not exist
        """
        snapshot_path = self.snapshots_path / snapshot_id
        if not snapshot_path.exists():
            raise ValueError(f"Snapshot {snapshot_id} does not exist")
    
        # Create a unique version ID
        version_id = create_unique_id("ver-")
    
        # Get the snapshot manifest to find the file
        manifest_path = snapshot_path / "manifest.json"
        try:
            manifest = load_json(manifest_path)
        except Exception as e:
            raise ValueError(f"Failed to load snapshot manifest: {e}")
    
        # Try to find the file in the manifest using different path formats
        # First try the original path as-is
        relative_path = str(file_path)
        if relative_path not in manifest["files"]:
            # Try using just the filename
            file_name = file_path.name
            matching_paths = [path for path in manifest["files"].keys() if path.endswith(file_name)]
            if matching_paths:
                relative_path = matching_paths[0]
            else:
                # If still not found, fail with a clear error
>               raise ValueError(f"File {relative_path} not found in snapshot {snapshot_id}")
E               ValueError: File /tmp/tmpv8fq7507/test_project/test_tracked_image.png not found in snapshot snapshot_20250616_042717_969772

creative_vault/timeline/timeline_manager.py:107: ValueError
----------------------------- Captured stdout call -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
__________________ TestTimelineManager.test_register_version ___________________

self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed136d0>
backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e937580>
timeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e936ad0>
test_project_dir = PosixPath('/tmp/tmpc_o0qfvh/test_project')
test_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')

    def test_register_version(self, backup_engine, timeline_manager, test_project_dir, test_image):
        """Test registering a version of a file in the timeline."""
        # First ensure the test image is in the test project directory
        target_path = test_project_dir / "test_image.png"
        shutil.copy(test_image, target_path)
    
        # Create a snapshot that includes the image
        snapshot_id = backup_engine.create_snapshot(test_project_dir)
    
        # Register a version
>       version_id = timeline_manager.register_version(target_path, snapshot_id)

tests/digital_artist/test_timeline_manager.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e936ad0>
file_path = PosixPath('/tmp/tmpc_o0qfvh/test_project/test_image.png')
snapshot_id = 'snapshot_20250616_042717_990020', metadata = None

    def register_version(
        self,
        file_path: Path,
        snapshot_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Register a new version of a file in the timeline.
    
        Args:
            file_path: Path to the file
            snapshot_id: ID of the snapshot containing this version
            metadata: Optional metadata about this version
    
        Returns:
            str: Unique version ID
    
        Raises:
            ValueError: If the snapshot does not exist
        """
        snapshot_path = self.snapshots_path / snapshot_id
        if not snapshot_path.exists():
            raise ValueError(f"Snapshot {snapshot_id} does not exist")
    
        # Create a unique version ID
        version_id = create_unique_id("ver-")
    
        # Get the snapshot manifest to find the file
        manifest_path = snapshot_path / "manifest.json"
        try:
            manifest = load_json(manifest_path)
        except Exception as e:
            raise ValueError(f"Failed to load snapshot manifest: {e}")
    
        # Try to find the file in the manifest using different path formats
        # First try the original path as-is
        relative_path = str(file_path)
        if relative_path not in manifest["files"]:
            # Try using just the filename
            file_name = file_path.name
            matching_paths = [path for path in manifest["files"].keys() if path.endswith(file_name)]
            if matching_paths:
                relative_path = matching_paths[0]
            else:
                # If still not found, fail with a clear error
>               raise ValueError(f"File {relative_path} not found in snapshot {snapshot_id}")
E               ValueError: File /tmp/tmpc_o0qfvh/test_project/test_image.png not found in snapshot snapshot_20250616_042717_990020

creative_vault/timeline/timeline_manager.py:107: ValueError
---------------------------- Captured stdout setup -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
__________________ TestTimelineManager.test_get_file_timeline __________________

self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed139a0>
backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e7ef610>
timeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e7ee050>
test_project_dir = PosixPath('/tmp/tmpnt00d7rp/test_project')
test_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')

    def test_get_file_timeline(self, backup_engine, timeline_manager, test_project_dir, test_image):
        """Test getting the timeline of versions for a file."""
        # Copy the test image to the test project directory
        target_path = test_project_dir / "test_image.png"
        shutil.copy(test_image, target_path)
    
        # Create a snapshot
        snapshot_id = backup_engine.create_snapshot(test_project_dir)
    
        # Register a version
>       version_id = timeline_manager.register_version(target_path, snapshot_id)

tests/digital_artist/test_timeline_manager.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e7ee050>
file_path = PosixPath('/tmp/tmpnt00d7rp/test_project/test_image.png')
snapshot_id = 'snapshot_20250616_042718_010163', metadata = None

    def register_version(
        self,
        file_path: Path,
        snapshot_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Register a new version of a file in the timeline.
    
        Args:
            file_path: Path to the file
            snapshot_id: ID of the snapshot containing this version
            metadata: Optional metadata about this version
    
        Returns:
            str: Unique version ID
    
        Raises:
            ValueError: If the snapshot does not exist
        """
        snapshot_path = self.snapshots_path / snapshot_id
        if not snapshot_path.exists():
            raise ValueError(f"Snapshot {snapshot_id} does not exist")
    
        # Create a unique version ID
        version_id = create_unique_id("ver-")
    
        # Get the snapshot manifest to find the file
        manifest_path = snapshot_path / "manifest.json"
        try:
            manifest = load_json(manifest_path)
        except Exception as e:
            raise ValueError(f"Failed to load snapshot manifest: {e}")
    
        # Try to find the file in the manifest using different path formats
        # First try the original path as-is
        relative_path = str(file_path)
        if relative_path not in manifest["files"]:
            # Try using just the filename
            file_name = file_path.name
            matching_paths = [path for path in manifest["files"].keys() if path.endswith(file_name)]
            if matching_paths:
                relative_path = matching_paths[0]
            else:
                # If still not found, fail with a clear error
>               raise ValueError(f"File {relative_path} not found in snapshot {snapshot_id}")
E               ValueError: File /tmp/tmpnt00d7rp/test_project/test_image.png not found in snapshot snapshot_20250616_042718_010163

creative_vault/timeline/timeline_manager.py:107: ValueError
---------------------------- Captured stdout setup -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
_________________ TestTimelineManager.test_generate_thumbnail __________________

self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed13c70>
backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e842fb0>
timeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e842e90>
test_project_dir = PosixPath('/tmp/tmp1pzm0tyv/test_project')
test_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')

    def test_generate_thumbnail(self, backup_engine, timeline_manager, test_project_dir, test_image):
        """Test generating a thumbnail preview for a version."""
        # Copy the test image to the test project directory
        target_path = test_project_dir / "test_image.png"
        shutil.copy(test_image, target_path)
    
        # Create a snapshot
        snapshot_id = backup_engine.create_snapshot(test_project_dir)
    
        # Register a version
>       version_id = timeline_manager.register_version(target_path, snapshot_id)

tests/digital_artist/test_timeline_manager.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e842e90>
file_path = PosixPath('/tmp/tmp1pzm0tyv/test_project/test_image.png')
snapshot_id = 'snapshot_20250616_042718_030327', metadata = None

    def register_version(
        self,
        file_path: Path,
        snapshot_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Register a new version of a file in the timeline.
    
        Args:
            file_path: Path to the file
            snapshot_id: ID of the snapshot containing this version
            metadata: Optional metadata about this version
    
        Returns:
            str: Unique version ID
    
        Raises:
            ValueError: If the snapshot does not exist
        """
        snapshot_path = self.snapshots_path / snapshot_id
        if not snapshot_path.exists():
            raise ValueError(f"Snapshot {snapshot_id} does not exist")
    
        # Create a unique version ID
        version_id = create_unique_id("ver-")
    
        # Get the snapshot manifest to find the file
        manifest_path = snapshot_path / "manifest.json"
        try:
            manifest = load_json(manifest_path)
        except Exception as e:
            raise ValueError(f"Failed to load snapshot manifest: {e}")
    
        # Try to find the file in the manifest using different path formats
        # First try the original path as-is
        relative_path = str(file_path)
        if relative_path not in manifest["files"]:
            # Try using just the filename
            file_name = file_path.name
            matching_paths = [path for path in manifest["files"].keys() if path.endswith(file_name)]
            if matching_paths:
                relative_path = matching_paths[0]
            else:
                # If still not found, fail with a clear error
>               raise ValueError(f"File {relative_path} not found in snapshot {snapshot_id}")
E               ValueError: File /tmp/tmp1pzm0tyv/test_project/test_image.png not found in snapshot snapshot_20250616_042718_030327

creative_vault/timeline/timeline_manager.py:107: ValueError
---------------------------- Captured stdout setup -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
__________________ TestTimelineManager.test_compare_versions ___________________

self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed13f70>
backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e811060>
timeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e812860>
test_project_dir = PosixPath('/tmp/tmpx1uoqsam/test_project')
test_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')
test_image_modified = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image_modified.png')

    def test_compare_versions(self, backup_engine, timeline_manager, test_project_dir,
                             test_image, test_image_modified):
        """Test comparing two versions of a file."""
        # Copy the test image to the test project directory
        target_path = test_project_dir / "test_image.png"
        shutil.copy(test_image, target_path)
    
        # Create an initial snapshot
        snapshot_id_1 = backup_engine.create_snapshot(test_project_dir)
    
        # Register the first version
>       version_id_1 = timeline_manager.register_version(target_path, snapshot_id_1)

tests/digital_artist/test_timeline_manager.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e812860>
file_path = PosixPath('/tmp/tmpx1uoqsam/test_project/test_image.png')
snapshot_id = 'snapshot_20250616_042718_050185', metadata = None

    def register_version(
        self,
        file_path: Path,
        snapshot_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Register a new version of a file in the timeline.
    
        Args:
            file_path: Path to the file
            snapshot_id: ID of the snapshot containing this version
            metadata: Optional metadata about this version
    
        Returns:
            str: Unique version ID
    
        Raises:
            ValueError: If the snapshot does not exist
        """
        snapshot_path = self.snapshots_path / snapshot_id
        if not snapshot_path.exists():
            raise ValueError(f"Snapshot {snapshot_id} does not exist")
    
        # Create a unique version ID
        version_id = create_unique_id("ver-")
    
        # Get the snapshot manifest to find the file
        manifest_path = snapshot_path / "manifest.json"
        try:
            manifest = load_json(manifest_path)
        except Exception as e:
            raise ValueError(f"Failed to load snapshot manifest: {e}")
    
        # Try to find the file in the manifest using different path formats
        # First try the original path as-is
        relative_path = str(file_path)
        if relative_path not in manifest["files"]:
            # Try using just the filename
            file_name = file_path.name
            matching_paths = [path for path in manifest["files"].keys() if path.endswith(file_name)]
            if matching_paths:
                relative_path = matching_paths[0]
            else:
                # If still not found, fail with a clear error
>               raise ValueError(f"File {relative_path} not found in snapshot {snapshot_id}")
E               ValueError: File /tmp/tmpx1uoqsam/test_project/test_image.png not found in snapshot snapshot_20250616_042718_050185

creative_vault/timeline/timeline_manager.py:107: ValueError
---------------------------- Captured stdout setup -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
__________ TestTimelineManager.test_timeline_filtering_by_time_range ___________

self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed4c280>
backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e7ee2f0>
timeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e7ec430>
test_project_dir = PosixPath('/tmp/tmptjemma9m/test_project')
test_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')

    def test_timeline_filtering_by_time_range(self, backup_engine, timeline_manager,
                                             test_project_dir, test_image):
        """Test filtering the timeline by time range."""
        # Copy the test image to the test project directory
        target_path = test_project_dir / "test_image.png"
        shutil.copy(test_image, target_path)
    
        # Create an initial snapshot
        snapshot_id_1 = backup_engine.create_snapshot(test_project_dir)
    
        # Register the first version
>       version_id_1 = timeline_manager.register_version(target_path, snapshot_id_1)

tests/digital_artist/test_timeline_manager.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e7ec430>
file_path = PosixPath('/tmp/tmptjemma9m/test_project/test_image.png')
snapshot_id = 'snapshot_20250616_042718_070167', metadata = None

    def register_version(
        self,
        file_path: Path,
        snapshot_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Register a new version of a file in the timeline.
    
        Args:
            file_path: Path to the file
            snapshot_id: ID of the snapshot containing this version
            metadata: Optional metadata about this version
    
        Returns:
            str: Unique version ID
    
        Raises:
            ValueError: If the snapshot does not exist
        """
        snapshot_path = self.snapshots_path / snapshot_id
        if not snapshot_path.exists():
            raise ValueError(f"Snapshot {snapshot_id} does not exist")
    
        # Create a unique version ID
        version_id = create_unique_id("ver-")
    
        # Get the snapshot manifest to find the file
        manifest_path = snapshot_path / "manifest.json"
        try:
            manifest = load_json(manifest_path)
        except Exception as e:
            raise ValueError(f"Failed to load snapshot manifest: {e}")
    
        # Try to find the file in the manifest using different path formats
        # First try the original path as-is
        relative_path = str(file_path)
        if relative_path not in manifest["files"]:
            # Try using just the filename
            file_name = file_path.name
            matching_paths = [path for path in manifest["files"].keys() if path.endswith(file_name)]
            if matching_paths:
                relative_path = matching_paths[0]
            else:
                # If still not found, fail with a clear error
>               raise ValueError(f"File {relative_path} not found in snapshot {snapshot_id}")
E               ValueError: File /tmp/tmptjemma9m/test_project/test_image.png not found in snapshot snapshot_20250616_042718_070167

creative_vault/timeline/timeline_manager.py:107: ValueError
---------------------------- Captured stdout setup -----------------------------
Failed to initialize repository: Object of type <class 'set'> is not JSON serializable
_________________________ test_chunk_size_constraints __________________________

    def test_chunk_size_constraints():
        """Test that chunks respect size constraints."""
        # Create a large repeating pattern
        data = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ" * 10000
    
        # Create chunkers with different min/max sizes
        chunker1 = AssetChunker(min_chunk_size=64 * 1024, max_chunk_size=128 * 1024)
        chunker2 = AssetChunker(min_chunk_size=32 * 1024, max_chunk_size=64 * 1024)
    
        # Chunk the data
        chunks1 = chunker1.chunk_data(data)
        chunks2 = chunker2.chunk_data(data)
    
        # Verify chunk sizes respect constraints
        for chunk in chunks1:
            assert len(chunk) >= 64 * 1024
>           assert len(chunk) <= 128 * 1024
E           AssertionError: assert 131073 <= (128 * 1024)
E            +  where 131073 = len(b'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKL...TUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFG')

tests/game_developer/asset_optimization/test_chunking.py:209: AssertionError
_____________________________ test_base_compressor _____________________________

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

test_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}

    def test_base_compressor(test_data):
        """Test the base asset compressor."""
        compressor = AssetCompressor()
    
        # Test compression and decompression of repeating data
>       compressed = compressor.compress(test_data["repeating"])

tests/game_developer/asset_optimization/test_compressor.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/compressor.py:37: in compress
    return compress_data(data)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
___________________________ test_texture_compressor ____________________________

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

test_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}

    def test_texture_compressor(test_data):
        """Test the texture compressor."""
        compressor = TextureCompressor()
    
        # Test compression and decompression
>       compressed = compressor.compress(test_data["mixed"])

tests/game_developer/asset_optimization/test_compressor.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/compressor.py:80: in compress
    return compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
____________________________ test_audio_compressor _____________________________

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 2, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 2

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

test_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}

    def test_audio_compressor(test_data):
        """Test the audio compressor."""
        compressor = AudioCompressor()
    
        # Test compression and decompression
>       compressed = compressor.compress(test_data["mixed"])

tests/game_developer/asset_optimization/test_compressor.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/compressor.py:111: in compress
    return compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 2, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 2

common/core/compression.py:54: CompressionError
____________________________ test_model_compressor _____________________________

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 5, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 5

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

test_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}

    def test_model_compressor(test_data):
        """Test the model compressor."""
        compressor = ModelCompressor()
    
        # Test compression and decompression
>       compressed = compressor.compress(test_data["mixed"])

tests/game_developer/asset_optimization/test_compressor.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/compressor.py:142: in compress
    return compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 5, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 5

common/core/compression.py:54: CompressionError
____________________________ test_delta_compressor _____________________________

data = b'BSDIFF403\x00\x00\x00\x00\x00\x00\x00,\x00\x00\x00\x00\x00\x00\x00\x16\x1f\x00\x00\x00\x00\x00\x00BZh91AY&SY\xf4\xda...\x94\xa6\x9ca\x00\x00\x1c\x04\x00?\xe2\xa0\x001\x00\xd3M\x03ji\r1H\x844J;\x97H\x947\xf4XC\xbc\xd1w$S\x85\t\tJi\xc6\x10'
algorithm = 9, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 9

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

test_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}

    def test_delta_compressor(test_data):
        """Test the delta compressor."""
        compressor = DeltaCompressor()
    
        # Create a source and target with some changes - use larger data to ensure compression savings
        # The issue with the previous test is that the data was too small for effective delta compression
        source_data = b"A" * 1000 + b"This is the original data with some content that will remain the same." + b"B" * 1000
        target_data = b"A" * 1000 + b"This is the modified data with some content that will remain the same." + b"B" * 1000
    
        # Create a delta
        delta = compressor.create_delta(source_data, target_data)
    
        # Due to overhead of the delta format, small changes in small files might not result in smaller delta
        # So we'll just make sure the delta works properly without checking size
    
        # Apply the delta to recreate the target
        reconstructed = compressor.apply_delta(source_data, delta)
    
        # Verify the reconstruction matches the target
        assert reconstructed == target_data
    
        # Test with the test data
        base = test_data["repeating"]
        modified = base[:-100] + b"MODIFIED" + base[-50:]  # Modify a small part
    
        delta = compressor.create_delta(base, modified)
        reconstructed = compressor.apply_delta(base, delta)
    
        assert reconstructed == modified
    
        # Test delta compression
>       compressed_delta = compressor.compress_delta(delta)

tests/game_developer/asset_optimization/test_compressor.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/compressor.py:191: in compress_delta
    return compress_data(delta_data, compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'BSDIFF403\x00\x00\x00\x00\x00\x00\x00,\x00\x00\x00\x00\x00\x00\x00\x16\x1f\x00\x00\x00\x00\x00\x00BZh91AY&SY\xf4\xda...\x94\xa6\x9ca\x00\x00\x1c\x04\x00?\xe2\xa0\x001\x00\xd3M\x03ji\r1H\x844J;\x97H\x947\xf4XC\xbc\xd1w$S\x85\t\tJi\xc6\x10'
algorithm = 9, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 9

common/core/compression.py:54: CompressionError
___________________________ test_compression_levels ____________________________

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

    def test_compression_levels():
        """Test different compression levels."""
        data = b"ABCDEFGH" * 10000  # Highly compressible data
    
        # Test different compression levels
        sizes = []
        for level in range(1, 10, 3):  # Test levels 1, 4, 7
            compressor = AssetCompressor()
>           compressed = compressor.compress(data)

tests/game_developer/asset_optimization/test_compressor.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/compressor.py:37: in compress
    return compress_data(data)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'
algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
___________________________ test_optimize_text_file ____________________________

data = b'This is a text file for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

optimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974e840460>
test_files = {'audio': PosixPath('/tmp/tmpz8f7mp7e/sound.wav'), 'image': PosixPath('/tmp/tmpz8f7mp7e/image.png'), 'model': PosixPath('/tmp/tmpz8f7mp7e/model.fbx'), 'text': PosixPath('/tmp/tmpz8f7mp7e/text_file.txt')}

    def test_optimize_text_file(optimization_manager, test_files):
        """Test optimizing a text file."""
        # Optimize the text file
>       file_info = optimization_manager.optimize_asset(test_files["text"])

tests/game_developer/asset_optimization/test_manager.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/manager.py:81: in optimize_asset
    file_hash, storage_path = self.storage_manager.store_file(file_path)
gamevault/backup_engine/storage.py:99: in store_file
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'This is a text file for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
__________________________ test_optimize_binary_file ___________________________

data = b'\x89PNG\r\n\x1a\n8e\xe3\xbd_\xdd\x0f?\xf6Ih\xb0\xf4\xa5\xeb\\,g\xbeVo\xdd\xb5m\xb4\xd5k\xa9\xe1\t\xa2>\x01\x9b\x1dB\...xfa\xb1\xa7\x05\x80\x1c\x10\xc4W\xa3\xee\xa6\xbd\xed\\\xc4K\x93\xe72>\x88\xc7\x10\x86\xfcr\x84\x8b3%\x10\xa2\xc5\x02+{'
algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

optimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974eace590>
test_files = {'audio': PosixPath('/tmp/tmpgmalfgyg/sound.wav'), 'image': PosixPath('/tmp/tmpgmalfgyg/image.png'), 'model': PosixPath('/tmp/tmpgmalfgyg/model.fbx'), 'text': PosixPath('/tmp/tmpgmalfgyg/text_file.txt')}

    def test_optimize_binary_file(optimization_manager, test_files):
        """Test optimizing a binary file."""
        # Create a larger binary file to ensure it generates chunks
        with open(test_files["image"], "wb") as f:
            f.write(b"\x89PNG\r\n\x1a\n")  # PNG header
            f.write(os.urandom(200000))  # Large random binary data
    
        # Optimize the image file
>       file_info = optimization_manager.optimize_asset(test_files["image"])

tests/game_developer/asset_optimization/test_manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/manager.py:141: in optimize_asset
    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]
gamevault/asset_optimization/manager.py:141: in <listcomp>
    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]
gamevault/asset_optimization/compressor.py:80: in compress
    return compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\x89PNG\r\n\x1a\n8e\xe3\xbd_\xdd\x0f?\xf6Ih\xb0\xf4\xa5\xeb\\,g\xbeVo\xdd\xb5m\xb4\xd5k\xa9\xe1\t\xa2>\x01\x9b\x1dB\...xfa\xb1\xa7\x05\x80\x1c\x10\xc4W\xa3\xee\xa6\xbd\xed\\\xc4K\x93\xe72>\x88\xc7\x10\x86\xfcr\x84\x8b3%\x10\xa2\xc5\x02+{'
algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
_____________________ test_optimize_with_previous_version ______________________

data = b'Kaydara FBX Binary\x00\x1b\x10\x983\x85\x1a[%sOP\xcc\xd5\x15Df\xd4\xbb\xd9\xa9$\xf9\x87U\x98M\x1a\x13\xa1\x9a\xf0t\x...3\xc8\xa3\xd2 b=\xf8\xe2\x03l\x90g\x82Zw\x0c\xd5T\xf6Mi\'\x1b\xc0\xeea\x08\x9d\xec\x93\x04&{\xc2\xac\x17M\xf7\x8b\xbez'
algorithm = 5, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 5

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

optimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974eb529e0>
test_files = {'audio': PosixPath('/tmp/tmpwl99ty34/sound.wav'), 'image': PosixPath('/tmp/tmpwl99ty34/image.png'), 'model': PosixPath('/tmp/tmpwl99ty34/model.fbx'), 'text': PosixPath('/tmp/tmpwl99ty34/text_file.txt')}

    def test_optimize_with_previous_version(optimization_manager, test_files):
        """Test optimizing a file with a previous version available."""
        # First optimize without a previous version
>       initial_info = optimization_manager.optimize_asset(test_files["model"])

tests/game_developer/asset_optimization/test_manager.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/manager.py:141: in optimize_asset
    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]
gamevault/asset_optimization/manager.py:141: in <listcomp>
    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]
gamevault/asset_optimization/compressor.py:142: in compress
    return compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'Kaydara FBX Binary\x00\x1b\x10\x983\x85\x1a[%sOP\xcc\xd5\x15Df\xd4\xbb\xd9\xa9$\xf9\x87U\x98M\x1a\x13\xa1\x9a\xf0t\x...3\xc8\xa3\xd2 b=\xf8\xe2\x03l\x90g\x82Zw\x0c\xd5T\xf6Mi\'\x1b\xc0\xeea\x08\x9d\xec\x93\x04&{\xc2\xac\x17M\xf7\x8b\xbez'
algorithm = 5, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 5

common/core/compression.py:54: CompressionError
______________________________ test_restore_asset ______________________________

data = b'This is a text file for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

optimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974ed12110>
test_files = {'audio': PosixPath('/tmp/tmpn7spfwd6/sound.wav'), 'image': PosixPath('/tmp/tmpn7spfwd6/image.png'), 'model': PosixPath('/tmp/tmpn7spfwd6/model.fbx'), 'text': PosixPath('/tmp/tmpn7spfwd6/text_file.txt')}

    def test_restore_asset(optimization_manager, test_files):
        """Test restoring an optimized asset."""
        # Optimize a text file which is simpler to restore
>       file_info = optimization_manager.optimize_asset(test_files["text"])

tests/game_developer/asset_optimization/test_manager.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/manager.py:81: in optimize_asset
    file_hash, storage_path = self.storage_manager.store_file(file_path)
gamevault/backup_engine/storage.py:99: in store_file
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'This is a text file for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
_________________________ test_get_optimization_stats __________________________

data = b'This is a text file for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

optimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974e86e110>
test_files = {'audio': PosixPath('/tmp/tmptjgwoonl/sound.wav'), 'image': PosixPath('/tmp/tmptjgwoonl/image.png'), 'model': PosixPath('/tmp/tmptjgwoonl/model.fbx'), 'text': PosixPath('/tmp/tmptjgwoonl/text_file.txt')}

    def test_get_optimization_stats(optimization_manager, test_files):
        """Test getting optimization statistics."""
        # Initially should have no storage used
        stats_before = optimization_manager.get_optimization_stats()
    
        # Optimize some files
>       optimization_manager.optimize_asset(test_files["text"])

tests/game_developer/asset_optimization/test_manager.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/manager.py:81: in optimize_asset
    file_hash, storage_path = self.storage_manager.store_file(file_path)
gamevault/backup_engine/storage.py:99: in store_file
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'This is a text file for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
________________________ test_get_shared_asset_analysis ________________________

data = b'Kaydara FBX Binary\x00\x01\xd0I\x86\x90\xcfz8BZ\x1e\t0\x8a\x89\xf0\x05{\x1b\xf2\'g\x80\xd7\x9c#i\xcf\xd6QU\x9e{\xb9{...|w]%\xa5\x1b\x1bC\xab\xb0?\xfb\\\x1d\xb3\x8b\xdfO\xcd,}\xd9\x16\xecd\xb5\x90\xba\x00Gr\x12\x08\x90!HgD[\x03H\n\x8b\x83'
algorithm = 5, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 5

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

optimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974c291360>
test_files = {'audio': PosixPath('/tmp/tmp4nbw08u0/sound.wav'), 'image': PosixPath('/tmp/tmp4nbw08u0/image.png'), 'model': PosixPath('/tmp/tmp4nbw08u0/model.fbx'), 'text': PosixPath('/tmp/tmp4nbw08u0/text_file.txt')}

    def test_get_shared_asset_analysis(optimization_manager, test_files):
        """Test analyzing shared asset content."""
        # Optimize some files
>       optimization_manager.optimize_asset(test_files["model"])

tests/game_developer/asset_optimization/test_manager.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/asset_optimization/manager.py:141: in optimize_asset
    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]
gamevault/asset_optimization/manager.py:141: in <listcomp>
    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]
gamevault/asset_optimization/compressor.py:142: in compress
    return compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'Kaydara FBX Binary\x00\x01\xd0I\x86\x90\xcfz8BZ\x1e\t0\x8a\x89\xf0\x05{\x1b\xf2\'g\x80\xd7\x9c#i\xcf\xd6QU\x9e{\xb9{...|w]%\xa5\x1b\x1bC\xab\xb0?\xfb\\\x1d\xb3\x8b\xdfO\xcd,}\xd9\x16\xecd\xb5\x90\xba\x00Gr\x12\x08\x90!HgD[\x03H\n\x8b\x83'
algorithm = 5, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 5

common/core/compression.py:54: CompressionError
____________________________ test_delta_compression ____________________________

optimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974e8413c0>
test_files = {'audio': PosixPath('/tmp/tmpenxn7uc7/sound.wav'), 'image': PosixPath('/tmp/tmpenxn7uc7/image.png'), 'model': PosixPath('/tmp/tmpenxn7uc7/model.fbx'), 'text': PosixPath('/tmp/tmpenxn7uc7/text_file.txt')}

    def test_delta_compression(optimization_manager, test_files):
        """Test delta compression between versions."""
        # Create a previous version file info
>       prev_version = FileInfo(
            path="test.bin",
            size=100,
            hash="prev_hash",
            modified_time=1000.0,
            is_binary=True,
            chunks=["chunk1", "chunk2"]
        )
E       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

tests/game_developer/asset_optimization/test_manager.py:181: TypeError
____________________________ test_get_base_version _____________________________

self = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974c290b50>
base_version_hash = 'test_base_version_hash'

    def _get_base_version(self, base_version_hash: str) -> FileInfo:
        """
        Get the base version for a delta-compressed file.
    
        Retrieves the FileInfo of a previous version based on its hash.
    
        Args:
            base_version_hash: Hash of the base version
    
        Returns:
            FileInfo: Information about the base version
    
        Raises:
            ValueError: If the base version can't be found
        """
        # Search for the file in the storage system by its hash
        try:
            # Check if the file exists in storage
            file_path = self.storage_manager.get_file_path_by_hash(base_version_hash)
            if file_path:
                # Create basic FileInfo from the stored file
                file_size = os.path.getsize(file_path)
                chunks = self.storage_manager.get_chunks_for_file(base_version_hash)
    
>               return FileInfo(
                    path=os.path.basename(file_path),
                    size=file_size,
                    hash=base_version_hash,
                    modified_time=os.path.getmtime(file_path),
                    is_binary=True,
                    chunks=chunks or []
                )
E               TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

gamevault/asset_optimization/manager.py:264: TypeError

During handling of the above exception, another exception occurred:

optimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974c290b50>

    def test_get_base_version(optimization_manager):
        """Test retrieving a base version using its hash."""
        # Setup mock for the storage manager methods
        test_hash = "test_base_version_hash"
        test_path = Path("/test/path/file.bin")
        test_size = 1024
        test_mtime = 1600000000.0
        test_chunks = ["chunk1", "chunk2", "chunk3"]
    
        # Test case 1: File exists in storage
        with patch.object(optimization_manager.storage_manager, "get_file_path_by_hash") as mock_get_path:
            with patch.object(optimization_manager.storage_manager, "get_chunks_for_file") as mock_get_chunks:
                with patch("os.path.getsize") as mock_getsize:
                    with patch("os.path.getmtime") as mock_getmtime:
                        # Set up the mocks
                        mock_get_path.return_value = test_path
                        mock_get_chunks.return_value = test_chunks
                        mock_getsize.return_value = test_size
                        mock_getmtime.return_value = test_mtime
    
                        # Call the method
>                       file_info = optimization_manager._get_base_version(test_hash)

tests/game_developer/asset_optimization/test_manager.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974c290b50>
base_version_hash = 'test_base_version_hash'

    def _get_base_version(self, base_version_hash: str) -> FileInfo:
        """
        Get the base version for a delta-compressed file.
    
        Retrieves the FileInfo of a previous version based on its hash.
    
        Args:
            base_version_hash: Hash of the base version
    
        Returns:
            FileInfo: Information about the base version
    
        Raises:
            ValueError: If the base version can't be found
        """
        # Search for the file in the storage system by its hash
        try:
            # Check if the file exists in storage
            file_path = self.storage_manager.get_file_path_by_hash(base_version_hash)
            if file_path:
                # Create basic FileInfo from the stored file
                file_size = os.path.getsize(file_path)
                chunks = self.storage_manager.get_chunks_for_file(base_version_hash)
    
                return FileInfo(
                    path=os.path.basename(file_path),
                    size=file_size,
                    hash=base_version_hash,
                    modified_time=os.path.getmtime(file_path),
                    is_binary=True,
                    chunks=chunks or []
                )
    
            # If no direct file is found, try looking for chunks
            chunks = self.storage_manager.get_chunks_for_file(base_version_hash)
            if chunks:
                # Return FileInfo with just the chunks
                return FileInfo(
                    path="unknown",  # Path is not critical for reconstruction
                    size=0,  # Size will be determined after reconstruction
                    hash=base_version_hash,
                    modified_time=0,  # Not critical for reconstruction
                    is_binary=True,
                    chunks=chunks
                )
    
            raise ValueError(f"Base version {base_version_hash} not found")
        except Exception as e:
>           raise ValueError(f"Failed to retrieve base version {base_version_hash}: {str(e)}")
E           ValueError: Failed to retrieve base version test_base_version_hash: FileInfo.__init__() got an unexpected keyword argument 'is_binary'

gamevault/asset_optimization/manager.py:288: ValueError
______________________________ test_create_backup ______________________________

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>
source_path = PosixPath('/tmp/tmp8gi_09nv/test_project')
tags = {'initial', 'test', 'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
>           current_files = self._scan_source_files(source_path)

common/core/backup_engine.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/core/backup_engine.py:390: in _scan_source_files
    for file_path in scan_directory(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

directory = PosixPath('/tmp/tmp8gi_09nv/test_project')
ignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]
follow_symlinks = False, include_hidden = False

    def scan_directory(
        directory: Union[str, Path],
        ignore_patterns: Optional[List[str]] = None,
        follow_symlinks: bool = False,
        include_hidden: bool = False
    ) -> Iterator[Path]:
        """
        Recursively scan directory for files.
    
        Args:
            directory: Directory to scan
            ignore_patterns: List of glob patterns to ignore
            follow_symlinks: Whether to follow symbolic links
            include_hidden: Whether to include hidden files/directories
    
        Yields:
            Path objects for each file found
        """
        directory = Path(directory)
        if not directory.exists() or not directory.is_dir():
            return
    
        ignore_patterns = ignore_patterns or []
    
        try:
            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):
                root_path = Path(root)
    
                # Filter hidden directories if not including them
                if not include_hidden:
                    dirs[:] = [d for d in dirs if not d.startswith('.')]
    
                # Apply ignore patterns to directories
                for pattern in ignore_patterns:
                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]
    
                for file in files:
                    # Skip hidden files if not including them
                    if not include_hidden and file.startswith('.'):
                        continue
    
                    file_path = root_path / file
    
                    # Apply ignore patterns to files
                    should_ignore = False
                    for pattern in ignore_patterns:
>                       if file_path.match(pattern) or file_path.name.match(pattern):
E                       AttributeError: 'str' object has no attribute 'match'

common/core/file_utils.py:62: AttributeError

During handling of the above exception, another exception occurred:

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>
name = 'test backup'
version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = 'Test backup', is_milestone = False, tags = ['test', 'initial']

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
>           snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )

gamevault/backup_engine/engine.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>
source_path = PosixPath('/tmp/tmp8gi_09nv/test_project')
tags = {'initial', 'test', 'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
            current_files = self._scan_source_files(source_path)
    
            # Calculate changes
            changes = self._calculate_changes(parent_files, current_files)
    
            # Store chunks for new/modified files
            stored_files = self._store_file_chunks(current_files, changes)
    
            # Create snapshot info
            snapshot = SnapshotInfo(
                id=snapshot_id,
                timestamp=datetime.now(),
                source_path=source_path,
                parent_id=parent_id,
                files=list(stored_files.values()),
                changes=changes,
                tags=tags or set()
            )
    
            # Store snapshot metadata
            self._store_snapshot_metadata(snapshot)
    
            return snapshot
    
        except Exception as e:
>           raise SnapshotError(f"Failed to create snapshot: {e}")
E           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'

common/core/backup_engine.py:135: SnapshotError

During handling of the above exception, another exception occurred:

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>
project_dir = PosixPath('/tmp/tmp8gi_09nv/test_project')

    def test_create_backup(backup_engine, project_dir):
        """Test creating a backup of a project."""
        # Create a backup
>       version = backup_engine.create_backup(
            name="test backup",
            version_type=GameVersionType.DEVELOPMENT,
            description="Test backup",
            is_milestone=False,
            tags=["test", "initial"]
        )

tests/game_developer/backup_engine/test_engine.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>
name = 'test backup'
version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = 'Test backup', is_milestone = False, tags = ['test', 'initial']

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
            snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )
    
            # Convert snapshot to ProjectVersion for game-specific interface
            project_version = ProjectVersion.from_common_snapshot_info(
                snapshot=snapshot,
                name=name,
                version_type=version_type,
                is_milestone=is_milestone
            )
    
            # Store game-specific metadata in the version tracker
            self.version_tracker.store_version_metadata(project_version)
    
            return project_version
    
        except Exception as e:
>           raise BackupSystemError(f"Failed to create backup: {e}")
E           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'

gamevault/backup_engine/engine.py:285: BackupSystemError
___________________________ test_incremental_backup ____________________________

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>
source_path = PosixPath('/tmp/tmpmvwbfp1o/test_project')
tags = {'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
>           current_files = self._scan_source_files(source_path)

common/core/backup_engine.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/core/backup_engine.py:390: in _scan_source_files
    for file_path in scan_directory(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

directory = PosixPath('/tmp/tmpmvwbfp1o/test_project')
ignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]
follow_symlinks = False, include_hidden = False

    def scan_directory(
        directory: Union[str, Path],
        ignore_patterns: Optional[List[str]] = None,
        follow_symlinks: bool = False,
        include_hidden: bool = False
    ) -> Iterator[Path]:
        """
        Recursively scan directory for files.
    
        Args:
            directory: Directory to scan
            ignore_patterns: List of glob patterns to ignore
            follow_symlinks: Whether to follow symbolic links
            include_hidden: Whether to include hidden files/directories
    
        Yields:
            Path objects for each file found
        """
        directory = Path(directory)
        if not directory.exists() or not directory.is_dir():
            return
    
        ignore_patterns = ignore_patterns or []
    
        try:
            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):
                root_path = Path(root)
    
                # Filter hidden directories if not including them
                if not include_hidden:
                    dirs[:] = [d for d in dirs if not d.startswith('.')]
    
                # Apply ignore patterns to directories
                for pattern in ignore_patterns:
                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]
    
                for file in files:
                    # Skip hidden files if not including them
                    if not include_hidden and file.startswith('.'):
                        continue
    
                    file_path = root_path / file
    
                    # Apply ignore patterns to files
                    should_ignore = False
                    for pattern in ignore_patterns:
>                       if file_path.match(pattern) or file_path.name.match(pattern):
E                       AttributeError: 'str' object has no attribute 'match'

common/core/file_utils.py:62: AttributeError

During handling of the above exception, another exception occurred:

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>
name = 'initial', version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = None, is_milestone = False, tags = None

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
>           snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )

gamevault/backup_engine/engine.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>
source_path = PosixPath('/tmp/tmpmvwbfp1o/test_project')
tags = {'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
            current_files = self._scan_source_files(source_path)
    
            # Calculate changes
            changes = self._calculate_changes(parent_files, current_files)
    
            # Store chunks for new/modified files
            stored_files = self._store_file_chunks(current_files, changes)
    
            # Create snapshot info
            snapshot = SnapshotInfo(
                id=snapshot_id,
                timestamp=datetime.now(),
                source_path=source_path,
                parent_id=parent_id,
                files=list(stored_files.values()),
                changes=changes,
                tags=tags or set()
            )
    
            # Store snapshot metadata
            self._store_snapshot_metadata(snapshot)
    
            return snapshot
    
        except Exception as e:
>           raise SnapshotError(f"Failed to create snapshot: {e}")
E           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'

common/core/backup_engine.py:135: SnapshotError

During handling of the above exception, another exception occurred:

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>
project_dir = PosixPath('/tmp/tmpmvwbfp1o/test_project')

    def test_incremental_backup(backup_engine, project_dir):
        """Test creating an incremental backup after changes."""
        # Create an initial backup
>       initial_version = backup_engine.create_backup(name="initial")

tests/game_developer/backup_engine/test_engine.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>
name = 'initial', version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = None, is_milestone = False, tags = None

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
            snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )
    
            # Convert snapshot to ProjectVersion for game-specific interface
            project_version = ProjectVersion.from_common_snapshot_info(
                snapshot=snapshot,
                name=name,
                version_type=version_type,
                is_milestone=is_milestone
            )
    
            # Store game-specific metadata in the version tracker
            self.version_tracker.store_version_metadata(project_version)
    
            return project_version
    
        except Exception as e:
>           raise BackupSystemError(f"Failed to create backup: {e}")
E           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'

gamevault/backup_engine/engine.py:285: BackupSystemError
_____________________________ test_restore_version _____________________________

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>
source_path = PosixPath('/tmp/tmp4v0ithlx/test_project')
tags = {'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
>           current_files = self._scan_source_files(source_path)

common/core/backup_engine.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/core/backup_engine.py:390: in _scan_source_files
    for file_path in scan_directory(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

directory = PosixPath('/tmp/tmp4v0ithlx/test_project')
ignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]
follow_symlinks = False, include_hidden = False

    def scan_directory(
        directory: Union[str, Path],
        ignore_patterns: Optional[List[str]] = None,
        follow_symlinks: bool = False,
        include_hidden: bool = False
    ) -> Iterator[Path]:
        """
        Recursively scan directory for files.
    
        Args:
            directory: Directory to scan
            ignore_patterns: List of glob patterns to ignore
            follow_symlinks: Whether to follow symbolic links
            include_hidden: Whether to include hidden files/directories
    
        Yields:
            Path objects for each file found
        """
        directory = Path(directory)
        if not directory.exists() or not directory.is_dir():
            return
    
        ignore_patterns = ignore_patterns or []
    
        try:
            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):
                root_path = Path(root)
    
                # Filter hidden directories if not including them
                if not include_hidden:
                    dirs[:] = [d for d in dirs if not d.startswith('.')]
    
                # Apply ignore patterns to directories
                for pattern in ignore_patterns:
                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]
    
                for file in files:
                    # Skip hidden files if not including them
                    if not include_hidden and file.startswith('.'):
                        continue
    
                    file_path = root_path / file
    
                    # Apply ignore patterns to files
                    should_ignore = False
                    for pattern in ignore_patterns:
>                       if file_path.match(pattern) or file_path.name.match(pattern):
E                       AttributeError: 'str' object has no attribute 'match'

common/core/file_utils.py:62: AttributeError

During handling of the above exception, another exception occurred:

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>
name = 'test', version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = None, is_milestone = False, tags = None

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
>           snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )

gamevault/backup_engine/engine.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>
source_path = PosixPath('/tmp/tmp4v0ithlx/test_project')
tags = {'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
            current_files = self._scan_source_files(source_path)
    
            # Calculate changes
            changes = self._calculate_changes(parent_files, current_files)
    
            # Store chunks for new/modified files
            stored_files = self._store_file_chunks(current_files, changes)
    
            # Create snapshot info
            snapshot = SnapshotInfo(
                id=snapshot_id,
                timestamp=datetime.now(),
                source_path=source_path,
                parent_id=parent_id,
                files=list(stored_files.values()),
                changes=changes,
                tags=tags or set()
            )
    
            # Store snapshot metadata
            self._store_snapshot_metadata(snapshot)
    
            return snapshot
    
        except Exception as e:
>           raise SnapshotError(f"Failed to create snapshot: {e}")
E           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'

common/core/backup_engine.py:135: SnapshotError

During handling of the above exception, another exception occurred:

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>
project_dir = PosixPath('/tmp/tmp4v0ithlx/test_project')

    def test_restore_version(backup_engine, project_dir):
        """Test restoring a backed up version."""
        # Create a backup
>       version = backup_engine.create_backup(name="test")

tests/game_developer/backup_engine/test_engine.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>
name = 'test', version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = None, is_milestone = False, tags = None

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
            snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )
    
            # Convert snapshot to ProjectVersion for game-specific interface
            project_version = ProjectVersion.from_common_snapshot_info(
                snapshot=snapshot,
                name=name,
                version_type=version_type,
                is_milestone=is_milestone
            )
    
            # Store game-specific metadata in the version tracker
            self.version_tracker.store_version_metadata(project_version)
    
            return project_version
    
        except Exception as e:
>           raise BackupSystemError(f"Failed to create backup: {e}")
E           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'

gamevault/backup_engine/engine.py:285: BackupSystemError
_________________________ test_restore_with_exclusions _________________________

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>
source_path = PosixPath('/tmp/tmpgjd0ogls/test_project')
tags = {'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
>           current_files = self._scan_source_files(source_path)

common/core/backup_engine.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/core/backup_engine.py:390: in _scan_source_files
    for file_path in scan_directory(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

directory = PosixPath('/tmp/tmpgjd0ogls/test_project')
ignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]
follow_symlinks = False, include_hidden = False

    def scan_directory(
        directory: Union[str, Path],
        ignore_patterns: Optional[List[str]] = None,
        follow_symlinks: bool = False,
        include_hidden: bool = False
    ) -> Iterator[Path]:
        """
        Recursively scan directory for files.
    
        Args:
            directory: Directory to scan
            ignore_patterns: List of glob patterns to ignore
            follow_symlinks: Whether to follow symbolic links
            include_hidden: Whether to include hidden files/directories
    
        Yields:
            Path objects for each file found
        """
        directory = Path(directory)
        if not directory.exists() or not directory.is_dir():
            return
    
        ignore_patterns = ignore_patterns or []
    
        try:
            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):
                root_path = Path(root)
    
                # Filter hidden directories if not including them
                if not include_hidden:
                    dirs[:] = [d for d in dirs if not d.startswith('.')]
    
                # Apply ignore patterns to directories
                for pattern in ignore_patterns:
                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]
    
                for file in files:
                    # Skip hidden files if not including them
                    if not include_hidden and file.startswith('.'):
                        continue
    
                    file_path = root_path / file
    
                    # Apply ignore patterns to files
                    should_ignore = False
                    for pattern in ignore_patterns:
>                       if file_path.match(pattern) or file_path.name.match(pattern):
E                       AttributeError: 'str' object has no attribute 'match'

common/core/file_utils.py:62: AttributeError

During handling of the above exception, another exception occurred:

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>
name = 'test', version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = None, is_milestone = False, tags = None

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
>           snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )

gamevault/backup_engine/engine.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>
source_path = PosixPath('/tmp/tmpgjd0ogls/test_project')
tags = {'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
            current_files = self._scan_source_files(source_path)
    
            # Calculate changes
            changes = self._calculate_changes(parent_files, current_files)
    
            # Store chunks for new/modified files
            stored_files = self._store_file_chunks(current_files, changes)
    
            # Create snapshot info
            snapshot = SnapshotInfo(
                id=snapshot_id,
                timestamp=datetime.now(),
                source_path=source_path,
                parent_id=parent_id,
                files=list(stored_files.values()),
                changes=changes,
                tags=tags or set()
            )
    
            # Store snapshot metadata
            self._store_snapshot_metadata(snapshot)
    
            return snapshot
    
        except Exception as e:
>           raise SnapshotError(f"Failed to create snapshot: {e}")
E           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'

common/core/backup_engine.py:135: SnapshotError

During handling of the above exception, another exception occurred:

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>
project_dir = PosixPath('/tmp/tmpgjd0ogls/test_project')

    def test_restore_with_exclusions(backup_engine, project_dir):
        """Test restoring a version with exclusions."""
        # Create a backup
>       version = backup_engine.create_backup(name="test")

tests/game_developer/backup_engine/test_engine.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>
name = 'test', version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = None, is_milestone = False, tags = None

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
            snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )
    
            # Convert snapshot to ProjectVersion for game-specific interface
            project_version = ProjectVersion.from_common_snapshot_info(
                snapshot=snapshot,
                name=name,
                version_type=version_type,
                is_milestone=is_milestone
            )
    
            # Store game-specific metadata in the version tracker
            self.version_tracker.store_version_metadata(project_version)
    
            return project_version
    
        except Exception as e:
>           raise BackupSystemError(f"Failed to create backup: {e}")
E           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'

gamevault/backup_engine/engine.py:285: BackupSystemError
____________________________ test_get_version_diff _____________________________

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>
source_path = PosixPath('/tmp/tmp4har2wl4/test_project')
tags = {'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
>           current_files = self._scan_source_files(source_path)

common/core/backup_engine.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
common/core/backup_engine.py:390: in _scan_source_files
    for file_path in scan_directory(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

directory = PosixPath('/tmp/tmp4har2wl4/test_project')
ignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]
follow_symlinks = False, include_hidden = False

    def scan_directory(
        directory: Union[str, Path],
        ignore_patterns: Optional[List[str]] = None,
        follow_symlinks: bool = False,
        include_hidden: bool = False
    ) -> Iterator[Path]:
        """
        Recursively scan directory for files.
    
        Args:
            directory: Directory to scan
            ignore_patterns: List of glob patterns to ignore
            follow_symlinks: Whether to follow symbolic links
            include_hidden: Whether to include hidden files/directories
    
        Yields:
            Path objects for each file found
        """
        directory = Path(directory)
        if not directory.exists() or not directory.is_dir():
            return
    
        ignore_patterns = ignore_patterns or []
    
        try:
            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):
                root_path = Path(root)
    
                # Filter hidden directories if not including them
                if not include_hidden:
                    dirs[:] = [d for d in dirs if not d.startswith('.')]
    
                # Apply ignore patterns to directories
                for pattern in ignore_patterns:
                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]
    
                for file in files:
                    # Skip hidden files if not including them
                    if not include_hidden and file.startswith('.'):
                        continue
    
                    file_path = root_path / file
    
                    # Apply ignore patterns to files
                    should_ignore = False
                    for pattern in ignore_patterns:
>                       if file_path.match(pattern) or file_path.name.match(pattern):
E                       AttributeError: 'str' object has no attribute 'match'

common/core/file_utils.py:62: AttributeError

During handling of the above exception, another exception occurred:

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>
name = 'initial', version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = None, is_milestone = False, tags = None

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
>           snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )

gamevault/backup_engine/engine.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>
source_path = PosixPath('/tmp/tmp4har2wl4/test_project')
tags = {'version_type:development'}

    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:
        """
        Create a new backup snapshot.
    
        Args:
            source_path: Path to directory or file to backup
            tags: Optional tags for the snapshot
    
        Returns:
            SnapshotInfo for the created snapshot
    
        Raises:
            SnapshotError: If snapshot creation fails
        """
        try:
            source_path = Path(source_path).resolve()
            if not source_path.exists():
                raise SnapshotError(f"Source path does not exist: {source_path}")
    
            # Generate snapshot ID
            snapshot_id = self._generate_snapshot_id()
    
            # Get parent snapshot for incremental backup
            parent_id = self._get_latest_snapshot_id(source_path)
            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}
    
            # Scan files in source
            current_files = self._scan_source_files(source_path)
    
            # Calculate changes
            changes = self._calculate_changes(parent_files, current_files)
    
            # Store chunks for new/modified files
            stored_files = self._store_file_chunks(current_files, changes)
    
            # Create snapshot info
            snapshot = SnapshotInfo(
                id=snapshot_id,
                timestamp=datetime.now(),
                source_path=source_path,
                parent_id=parent_id,
                files=list(stored_files.values()),
                changes=changes,
                tags=tags or set()
            )
    
            # Store snapshot metadata
            self._store_snapshot_metadata(snapshot)
    
            return snapshot
    
        except Exception as e:
>           raise SnapshotError(f"Failed to create snapshot: {e}")
E           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'

common/core/backup_engine.py:135: SnapshotError

During handling of the above exception, another exception occurred:

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>
project_dir = PosixPath('/tmp/tmp4har2wl4/test_project')

    def test_get_version_diff(backup_engine, project_dir):
        """Test getting differences between two versions."""
        # Create an initial backup
>       initial_version = backup_engine.create_backup(name="initial")

tests/game_developer/backup_engine/test_engine.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>
name = 'initial', version_type = <GameVersionType.DEVELOPMENT: 'development'>
description = None, is_milestone = False, tags = None

    def create_backup(
        self,
        name: str,
        version_type: GameVersionType = GameVersionType.DEVELOPMENT,
        description: Optional[str] = None,
        is_milestone: bool = False,
        tags: Optional[List[str]] = None
    ) -> ProjectVersion:
        """
        Create a backup of the project using unified engine infrastructure.
    
        Args:
            name: Name of the backup version
            version_type: Type of the version
            description: Description of the version
            is_milestone: Whether this version is a milestone
            tags: List of tags for this version
    
        Returns:
            ProjectVersion: The created version
        """
        try:
            # Convert tags to set for common engine
            snapshot_tags = set(tags) if tags else set()
            snapshot_tags.add(f"version_type:{version_type.value}")
            if is_milestone:
                snapshot_tags.add("milestone")
    
            # Create snapshot using common engine
            snapshot = self.create_snapshot(
                source_path=self.project_path,
                tags=snapshot_tags
            )
    
            # Convert snapshot to ProjectVersion for game-specific interface
            project_version = ProjectVersion.from_common_snapshot_info(
                snapshot=snapshot,
                name=name,
                version_type=version_type,
                is_milestone=is_milestone
            )
    
            # Store game-specific metadata in the version tracker
            self.version_tracker.store_version_metadata(project_version)
    
            return project_version
    
        except Exception as e:
>           raise BackupSystemError(f"Failed to create backup: {e}")
E           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'

gamevault/backup_engine/engine.py:285: BackupSystemError
____________________________ test_get_storage_stats ____________________________

backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2aa380>
project_dir = PosixPath('/tmp/tmpkjsveir7/test_project')

    def test_get_storage_stats(backup_engine, project_dir):
        """Test getting storage statistics."""
        # Initially should have no storage used
        stats_before = backup_engine.get_storage_stats()
>       assert stats_before["total"] == 0
E       KeyError: 'total'

tests/game_developer/backup_engine/test_engine.py:203: KeyError
_______________________________ test_store_file ________________________________

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

storage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974eb507c0>
sample_file = '/tmp/tmplhd4k7n1'

    def test_store_file(storage_manager, sample_file):
        """Test storing a file in the storage manager."""
        # Store the file
>       file_id, storage_path = storage_manager.store_file(sample_file)

tests/game_developer/backup_engine/test_storage.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/backup_engine/storage.py:99: in store_file
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
______________________________ test_retrieve_file ______________________________

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

storage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974c2b1ba0>
sample_file = '/tmp/tmpwmilcq2i'

    def test_retrieve_file(storage_manager, sample_file):
        """Test retrieving a stored file."""
        # Store the file
>       file_id, _ = storage_manager.store_file(sample_file)

tests/game_developer/backup_engine/test_storage.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/backup_engine/storage.py:99: in store_file
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
________________________ test_store_and_retrieve_chunks ________________________

data = b'Chunk 1 data', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

storage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974c2d3c70>
sample_chunks = [b'Chunk 1 data', b'Chunk 2 data with more content', b'Another chunk with different content']

    def test_store_and_retrieve_chunks(storage_manager, sample_chunks):
        """Test storing and retrieving chunks."""
        # Store the chunks
        chunk_ids = []
        for chunk in sample_chunks:
>           chunk_id = storage_manager.store_chunk(chunk)

tests/game_developer/backup_engine/test_storage.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/backup_engine/storage.py:150: in store_chunk
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'Chunk 1 data', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
_______________________________ test_remove_file _______________________________

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

storage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974e7f9a50>
sample_file = '/tmp/tmpmefd9gy_'

    def test_remove_file(storage_manager, sample_file):
        """Test removing a stored file."""
        # Store the file
>       file_id, _ = storage_manager.store_file(sample_file)

tests/game_developer/backup_engine/test_storage.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/backup_engine/storage.py:99: in store_file
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
______________________________ test_remove_chunk _______________________________

data = b'Chunk 1 data', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

storage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974e936440>
sample_chunks = [b'Chunk 1 data', b'Chunk 2 data with more content', b'Another chunk with different content']

    def test_remove_chunk(storage_manager, sample_chunks):
        """Test removing a stored chunk."""
        # Store a chunk
>       chunk_id = storage_manager.store_chunk(sample_chunks[0])

tests/game_developer/backup_engine/test_storage.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/backup_engine/storage.py:150: in store_chunk
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'Chunk 1 data', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
____________________________ test_get_storage_size _____________________________

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

storage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974eace440>
sample_file = '/tmp/tmpiystuuvv'
sample_chunks = [b'Chunk 1 data', b'Chunk 2 data with more content', b'Another chunk with different content']

    def test_get_storage_size(storage_manager, sample_file, sample_chunks):
        """Test getting storage size information."""
        # Initially, storage should be empty
        sizes = storage_manager.get_storage_size()
        assert sizes["files"] == 0
        assert sizes["chunks"] == 0
        assert sizes["total"] == 0
    
        # Store a file
>       storage_manager.store_file(sample_file)

tests/game_developer/backup_engine/test_storage.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/backup_engine/storage.py:99: in store_file
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
___________________________ test_idempotent_storage ____________________________

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

storage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974e854790>
sample_file = '/tmp/tmpflg6d2s1'

    def test_idempotent_storage(storage_manager, sample_file):
        """Test that storing the same file multiple times is idempotent."""
        # Store the file twice
>       file_id1, storage_path1 = storage_manager.store_file(sample_file)

tests/game_developer/backup_engine/test_storage.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/backup_engine/storage.py:99: in store_file
    compressed_data = compress_data(data, self.compression_level)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'Sample file content for testing', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
_________________________ test_save_and_get_checkpoint _________________________

data = b'BINARY_CHECKPOINT_DATA', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

playtest_recorder = <gamevault.playtest_recorder.recorder.PlaytestRecorder object at 0x7f974c280eb0>

    def test_save_and_get_checkpoint(playtest_recorder):
        """Test saving and retrieving checkpoint data."""
        # Start a session
        session_id = playtest_recorder.start_session(
            version_id="version123",
            player_id="player456"
        )
    
        # Create checkpoint data
        checkpoint_data = b"BINARY_CHECKPOINT_DATA"
    
        # Save the checkpoint
>       checkpoint_id = playtest_recorder.save_checkpoint(
            session_id,
            checkpoint_data,
            "Level 1 completion"
        )

tests/game_developer/playtest_recorder/test_recorder.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/playtest_recorder/recorder.py:225: in save_checkpoint
    self.storage.save_checkpoint(session_id, checkpoint_id, data, description)
gamevault/playtest_recorder/storage.py:363: in save_checkpoint
    compressed_data = compress_data(data)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'BINARY_CHECKPOINT_DATA', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
_________________________ test_save_and_get_checkpoint _________________________

data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

playtest_storage = <gamevault.playtest_recorder.storage.PlaytestStorage object at 0x7f974c2b1f90>
sample_session = PlaytestSession(id='session123', version_id='version456', player_id='player789', timestamp=1623456789.0, duration=600.....0, 'health': 75.0, 'enemies_defeated': 5.0, 'collectibles_found': 3.0}, checkpoint_ids=['checkpoint1', 'checkpoint2'])
sample_checkpoint_data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING'

    def test_save_and_get_checkpoint(playtest_storage, sample_session, sample_checkpoint_data):
        """Test saving and retrieving checkpoint data."""
        # Save the session first
        playtest_storage.save_session(sample_session)
    
        # Save a checkpoint
        checkpoint_id = "test_checkpoint"
        checkpoint_desc = "Test checkpoint description"
>       playtest_storage.save_checkpoint(
            sample_session.id,
            checkpoint_id,
            sample_checkpoint_data,
            checkpoint_desc
        )

tests/game_developer/playtest_recorder/test_storage.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/playtest_recorder/storage.py:363: in save_checkpoint
    compressed_data = compress_data(data)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
____________________________ test_list_checkpoints _____________________________

data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
>               raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
E               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3

common/core/compression.py:51: CompressionError

During handling of the above exception, another exception occurred:

playtest_storage = <gamevault.playtest_recorder.storage.PlaytestStorage object at 0x7f974c337fa0>
sample_session = PlaytestSession(id='session123', version_id='version456', player_id='player789', timestamp=1623456789.0, duration=600.....0, 'health': 75.0, 'enemies_defeated': 5.0, 'collectibles_found': 3.0}, checkpoint_ids=['checkpoint1', 'checkpoint2'])
sample_checkpoint_data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING'

    def test_list_checkpoints(playtest_storage, sample_session, sample_checkpoint_data):
        """Test listing checkpoints for a session."""
        # Save the session
        playtest_storage.save_session(sample_session)
    
        # Save multiple checkpoints
        checkpoint_ids = ["checkpoint1", "checkpoint2", "checkpoint3"]
        for i, checkpoint_id in enumerate(checkpoint_ids):
>           playtest_storage.save_checkpoint(
                sample_session.id,
                checkpoint_id,
                sample_checkpoint_data,
                f"Checkpoint {i+1}"
            )

tests/game_developer/playtest_recorder/test_storage.py:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
gamevault/playtest_recorder/storage.py:363: in save_checkpoint
    compressed_data = compress_data(data)
gamevault/utils.py:76: in compress_data
    return common_compress_data(data, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING', algorithm = 3, level = 3

    def compress_data(data: bytes, algorithm: str = "zstd", level: int = 3) -> bytes:
        """
        Compress data using specified algorithm.
    
        Args:
            data: Data to compress
            algorithm: Compression algorithm ('zstd', 'zlib', 'none')
            level: Compression level (0-22 for zstd, 0-9 for zlib)
    
        Returns:
            Compressed data
    
        Raises:
            CompressionError: If compression fails
        """
        try:
            if algorithm == "none":
                return data
            elif algorithm == "zstd":
                if not HAS_ZSTD:
                    # Fallback to zlib if zstd not available
                    return zlib.compress(data, level=min(level, 9))
    
                compressor = zstd.ZstdCompressor(level=level)
                return compressor.compress(data)
            elif algorithm == "zlib":
                return zlib.compress(data, level=min(level, 9))
            else:
                raise CompressionError(f"Unsupported compression algorithm: {algorithm}")
    
        except Exception as e:
>           raise CompressionError(f"Compression failed: {e}")
E           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3

common/core/compression.py:54: CompressionError
=============================== warnings summary ===============================
../../../../.pyenv/versions/3.10.11/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /home/justinchiu_cohere_com/.pyenv/versions/3.10.11/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

common/core/config.py:44
  /home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/config.py:44: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('backup_dir')

common/core/config.py:53
  /home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/config.py:53: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    @validator('ignore_patterns')

tests/digital_artist/test_backup_engine.py: 6 warnings
tests/digital_artist/test_integration.py: 5 warnings
tests/digital_artist/test_timeline_manager.py: 5 warnings
  /home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py:123: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    "config": self.config.dict(),

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
--------------------------------- JSON report ----------------------------------
report saved to: report.json
=========================== short test summary info ============================
FAILED tests/digital_artist/test_asset_tracker.py::test_scan_project - TypeEr...
FAILED tests/digital_artist/test_backup_engine.py::test_initialize_repository
FAILED tests/digital_artist/test_backup_engine.py::test_create_snapshot - Ass...
FAILED tests/digital_artist/test_backup_engine.py::test_restore_snapshot - as...
FAILED tests/digital_artist/test_backup_engine.py::test_incremental_backup - ...
FAILED tests/digital_artist/test_integration.py::test_full_backup_restore_workflow
FAILED tests/digital_artist/test_integration.py::test_version_comparison_workflow
FAILED tests/digital_artist/test_integration.py::test_multi_snapshot_timeline
FAILED tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_register_version
FAILED tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_get_file_timeline
FAILED tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_generate_thumbnail
FAILED tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_compare_versions
FAILED tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_timeline_filtering_by_time_range
FAILED tests/game_developer/asset_optimization/test_chunking.py::test_chunk_size_constraints
FAILED tests/game_developer/asset_optimization/test_compressor.py::test_base_compressor
FAILED tests/game_developer/asset_optimization/test_compressor.py::test_texture_compressor
FAILED tests/game_developer/asset_optimization/test_compressor.py::test_audio_compressor
FAILED tests/game_developer/asset_optimization/test_compressor.py::test_model_compressor
FAILED tests/game_developer/asset_optimization/test_compressor.py::test_delta_compressor
FAILED tests/game_developer/asset_optimization/test_compressor.py::test_compression_levels
FAILED tests/game_developer/asset_optimization/test_manager.py::test_optimize_text_file
FAILED tests/game_developer/asset_optimization/test_manager.py::test_optimize_binary_file
FAILED tests/game_developer/asset_optimization/test_manager.py::test_optimize_with_previous_version
FAILED tests/game_developer/asset_optimization/test_manager.py::test_restore_asset
FAILED tests/game_developer/asset_optimization/test_manager.py::test_get_optimization_stats
FAILED tests/game_developer/asset_optimization/test_manager.py::test_get_shared_asset_analysis
FAILED tests/game_developer/asset_optimization/test_manager.py::test_delta_compression
FAILED tests/game_developer/asset_optimization/test_manager.py::test_get_base_version
FAILED tests/game_developer/backup_engine/test_engine.py::test_create_backup
FAILED tests/game_developer/backup_engine/test_engine.py::test_incremental_backup
FAILED tests/game_developer/backup_engine/test_engine.py::test_restore_version
FAILED tests/game_developer/backup_engine/test_engine.py::test_restore_with_exclusions
FAILED tests/game_developer/backup_engine/test_engine.py::test_get_version_diff
FAILED tests/game_developer/backup_engine/test_engine.py::test_get_storage_stats
FAILED tests/game_developer/backup_engine/test_storage.py::test_store_file - ...
FAILED tests/game_developer/backup_engine/test_storage.py::test_retrieve_file
FAILED tests/game_developer/backup_engine/test_storage.py::test_store_and_retrieve_chunks
FAILED tests/game_developer/backup_engine/test_storage.py::test_remove_file
FAILED tests/game_developer/backup_engine/test_storage.py::test_remove_chunk
FAILED tests/game_developer/backup_engine/test_storage.py::test_get_storage_size
FAILED tests/game_developer/backup_engine/test_storage.py::test_idempotent_storage
FAILED tests/game_developer/playtest_recorder/test_recorder.py::test_save_and_get_checkpoint
FAILED tests/game_developer/playtest_recorder/test_storage.py::test_save_and_get_checkpoint
FAILED tests/game_developer/playtest_recorder/test_storage.py::test_list_checkpoints
ERROR tests/game_developer/backup_engine/test_version_tracker.py::test_create_version
ERROR tests/game_developer/backup_engine/test_version_tracker.py::test_create_version_with_parent
ERROR tests/game_developer/backup_engine/test_version_tracker.py::test_get_version
ERROR tests/game_developer/backup_engine/test_version_tracker.py::test_list_versions
ERROR tests/game_developer/backup_engine/test_version_tracker.py::test_get_version_history
ERROR tests/game_developer/backup_engine/test_version_tracker.py::test_get_milestones
ERROR tests/game_developer/backup_engine/test_version_tracker.py::test_get_versions_by_tag
ERROR tests/game_developer/backup_engine/test_version_tracker.py::test_get_versions_by_type
ERROR tests/game_developer/backup_engine/test_version_tracker.py::test_delete_version
ERROR tests/game_developer/integration/test_game_development_workflow.py::test_complete_game_development_cycle
ERROR tests/game_developer/integration/test_game_development_workflow.py::test_milestone_annotations
ERROR tests/game_developer/integration/test_game_development_workflow.py::test_platform_specific_features
ERROR tests/game_developer/integration/test_game_development_workflow.py::test_configuration_management_across_platforms
====== 44 failed, 125 passed, 12 skipped, 19 warnings, 13 errors in 5.87s ======
