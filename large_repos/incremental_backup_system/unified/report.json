{"created": 1750048042.5268617, "duration": 5.84417462348938, "exitcode": 1, "root": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified", "environment": {}, "summary": {"failed": 44, "passed": 125, "error": 13, "skipped": 12, "total": 194, "collected": 194}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests", "type": "Package"}]}, {"nodeid": "tests/digital_artist/test_asset_tracker.py", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist/test_asset_tracker.py::test_scan_project", "type": "Function", "lineno": 13}, {"nodeid": "tests/digital_artist/test_asset_tracker.py::test_get_referenced_assets", "type": "Function", "lineno": 42}, {"nodeid": "tests/digital_artist/test_asset_tracker.py::test_asset_deduplication", "type": "Function", "lineno": 55}, {"nodeid": "tests/digital_artist/test_asset_tracker.py::test_update_reference", "type": "Function", "lineno": 102}, {"nodeid": "tests/digital_artist/test_asset_tracker.py::test_error_handling_for_nonexistent_files", "type": "Function", "lineno": 135}]}, {"nodeid": "tests/digital_artist/test_backup_engine.py", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist/test_backup_engine.py::test_initialize_repository", "type": "Function", "lineno": 14}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_create_snapshot", "type": "Function", "lineno": 35}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_restore_snapshot", "type": "Function", "lineno": 52}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_get_snapshot_info", "type": "Function", "lineno": 78}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_list_snapshots", "type": "Function", "lineno": 98}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_incremental_backup", "type": "Function", "lineno": 115}]}, {"nodeid": "tests/digital_artist/test_data", "outcome": "passed", "result": []}, {"nodeid": "tests/digital_artist/test_element_extraction.py", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist/test_element_extraction.py::test_list_elements_for_image", "type": "Function", "lineno": 13}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_extract_whole_image", "type": "Function", "lineno": 33}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_extract_image_region", "type": "Function", "lineno": 58}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_replace_image_region", "type": "Function", "lineno": 87}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_list_elements_for_3d_model", "type": "Function", "lineno": 122}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_extract_whole_model", "type": "Function", "lineno": 138}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_error_handling_for_invalid_element", "type": "Function", "lineno": 161}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_error_handling_for_nonexistent_file", "type": "Function", "lineno": 168}]}, {"nodeid": "tests/digital_artist/test_integration.py", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist/test_integration.py::test_full_backup_restore_workflow", "type": "Function", "lineno": 14}, {"nodeid": "tests/digital_artist/test_integration.py::test_version_comparison_workflow", "type": "Function", "lineno": 46}, {"nodeid": "tests/digital_artist/test_integration.py::test_element_extraction_workflow", "type": "Function", "lineno": 91}, {"nodeid": "tests/digital_artist/test_integration.py::test_asset_deduplication_workflow", "type": "Function", "lineno": 121}, {"nodeid": "tests/digital_artist/test_integration.py::test_multi_snapshot_timeline", "type": "Function", "lineno": 168}]}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_register_version", "type": "Function", "lineno": 35}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_get_file_timeline", "type": "Function", "lineno": 57}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_generate_thumbnail", "type": "Function", "lineno": 86}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_compare_versions", "type": "Function", "lineno": 112}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_timeline_filtering_by_time_range", "type": "Function", "lineno": 152}]}, {"nodeid": "tests/digital_artist/test_timeline_manager.py", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager", "type": "Class"}]}, {"nodeid": "tests/digital_artist/test_visual_diff.py", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist/test_visual_diff.py::test_generate_image_diff", "type": "Function", "lineno": 13}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_generate_model_diff", "type": "Function", "lineno": 27}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_get_diff_stats_for_images", "type": "Function", "lineno": 41}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_get_diff_stats_for_models", "type": "Function", "lineno": 62}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_diff_generation_with_custom_output_path", "type": "Function", "lineno": 81}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_error_handling_for_nonexistent_files", "type": "Function", "lineno": 98}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_diff_for_different_image_sizes", "type": "Function", "lineno": 111}]}, {"nodeid": "tests/digital_artist/test_workspace_capture.py", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist/test_workspace_capture.py::test_get_supported_applications", "type": "Function", "lineno": 14}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_get_application_info", "type": "Function", "lineno": 30}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_capture_workspace_mock", "type": "Function", "lineno": 53}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_restore_workspace_mock", "type": "Function", "lineno": 113}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_error_handling_for_nonexistent_workspace", "type": "Function", "lineno": 167}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_list_workspace_states", "type": "Function", "lineno": 176}]}, {"nodeid": "tests/digital_artist", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist/test_asset_tracker.py", "type": "Module"}, {"nodeid": "tests/digital_artist/test_backup_engine.py", "type": "Module"}, {"nodeid": "tests/digital_artist/test_data", "type": "Package"}, {"nodeid": "tests/digital_artist/test_element_extraction.py", "type": "Module"}, {"nodeid": "tests/digital_artist/test_integration.py", "type": "Module"}, {"nodeid": "tests/digital_artist/test_timeline_manager.py", "type": "Module"}, {"nodeid": "tests/digital_artist/test_visual_diff.py", "type": "Module"}, {"nodeid": "tests/digital_artist/test_workspace_capture.py", "type": "Module"}]}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_base_chunker", "type": "Function", "lineno": 62}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_texture_chunker", "type": "Function", "lineno": 84}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_audio_chunker", "type": "Function", "lineno": 105}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_model_chunker", "type": "Function", "lineno": 125}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_chunker_factory", "type": "Function", "lineno": 145}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_chunker_edge_cases", "type": "Function", "lineno": 170}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_chunk_size_constraints", "type": "Function", "lineno": 192}]}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_base_compressor", "type": "Function", "lineno": 32}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_texture_compressor", "type": "Function", "lineno": 54}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_audio_compressor", "type": "Function", "lineno": 69}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_model_compressor", "type": "Function", "lineno": 84}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_compressor_factory", "type": "Function", "lineno": 99}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_delta_compressor", "type": "Function", "lineno": 124}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_compression_levels", "type": "Function", "lineno": 167}]}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_add_chunk", "type": "Function", "lineno": 33}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_remove_chunk", "type": "Function", "lineno": 63}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_remove_file", "type": "Function", "lineno": 97}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_get_duplicate_chunks", "type": "Function", "lineno": 126}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_get_storage_savings", "type": "Function", "lineno": 158}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_get_file_sharing_stats", "type": "Function", "lineno": 192}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_asset_deduplicator_deduplicate_file", "type": "Function", "lineno": 217}]}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_optimize_text_file", "type": "Function", "lineno": 65}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_optimize_binary_file", "type": "Function", "lineno": 77}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_optimize_with_previous_version", "type": "Function", "lineno": 95}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_restore_asset", "type": "Function", "lineno": 121}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_get_optimization_stats", "type": "Function", "lineno": 148}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_get_shared_asset_analysis", "type": "Function", "lineno": 164}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_delta_compression", "type": "Function", "lineno": 177}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_get_base_version", "type": "Function", "lineno": 264}]}, {"nodeid": "tests/game_developer/asset_optimization", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/asset_optimization/test_chunking.py", "type": "Module"}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py", "type": "Module"}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py", "type": "Module"}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py", "type": "Module"}]}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_fixed_size_chunker", "type": "Function", "lineno": 32}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_rolling_hash_chunker", "type": "Function", "lineno": 62}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_game_asset_chunker", "type": "Function", "lineno": 98}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_chunker_edge_cases", "type": "Function", "lineno": 132}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_chunker_consistency", "type": "Function", "lineno": 153}]}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_create_backup", "type": "Function", "lineno": 55}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_incremental_backup", "type": "Function", "lineno": 81}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_restore_version", "type": "Function", "lineno": 119}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_restore_with_exclusions", "type": "Function", "lineno": 151}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_get_version_diff", "type": "Function", "lineno": 174}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_get_storage_stats", "type": "Function", "lineno": 198}]}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_store_file", "type": "Function", "lineno": 45}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_retrieve_file", "type": "Function", "lineno": 58}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_store_and_retrieve_chunks", "type": "Function", "lineno": 82}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_remove_file", "type": "Function", "lineno": 100}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_remove_chunk", "type": "Function", "lineno": 120}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_get_storage_size", "type": "Function", "lineno": 140}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_file_not_found", "type": "Function", "lineno": 164}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_chunk_not_found", "type": "Function", "lineno": 170}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_idempotent_storage", "type": "Function", "lineno": 176}]}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_create_version", "type": "Function", "lineno": 53}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_create_version_with_parent", "type": "Function", "lineno": 86}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_version", "type": "Function", "lineno": 113}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_list_versions", "type": "Function", "lineno": 130}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_version_history", "type": "Function", "lineno": 145}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_milestones", "type": "Function", "lineno": 162}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_versions_by_tag", "type": "Function", "lineno": 180}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_versions_by_type", "type": "Function", "lineno": 203}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_delete_version", "type": "Function", "lineno": 238}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_version_not_found", "type": "Function", "lineno": 266}]}, {"nodeid": "tests/game_developer/backup_engine", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/backup_engine/test_chunking.py", "type": "Module"}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py", "type": "Module"}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py", "type": "Module"}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py", "type": "Module"}]}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_common_terms", "type": "Function", "lineno": 137}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_feedback_over_time", "type": "Function", "lineno": 161}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_identify_recurring_issues", "type": "Function", "lineno": 180}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_sentiment_distribution", "type": "Function", "lineno": 198}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_analyze_feature_feedback", "type": "Function", "lineno": 213}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_player_engagement", "type": "Function", "lineno": 227}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_player_engagement_no_feedback", "type": "Function", "lineno": 247}]}, {"nodeid": "tests/game_developer/feedback_system/test_database.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/feedback_system/test_database.py::test_add_feedback", "type": "Function", "lineno": 37}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_update_feedback", "type": "Function", "lineno": 60}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_delete_feedback", "type": "Function", "lineno": 87}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_list_feedback", "type": "Function", "lineno": 107}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_count_feedback", "type": "Function", "lineno": 183}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_get_feedback_by_versions", "type": "Function", "lineno": 224}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_get_feedback_stats", "type": "Function", "lineno": 273}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_update_nonexistent_feedback", "type": "Function", "lineno": 313}]}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_add_feedback", "type": "Function", "lineno": 44}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_add_feedback_invalid_version", "type": "Function", "lineno": 73}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_update_feedback", "type": "Function", "lineno": 85}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_delete_feedback", "type": "Function", "lineno": 110}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_mark_feedback_resolved", "type": "Function", "lineno": 131}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_add_tags_to_feedback", "type": "Function", "lineno": 159}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_remove_tags_from_feedback", "type": "Function", "lineno": 186}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_add_metadata_to_feedback", "type": "Function", "lineno": 208}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_get_feedback_for_version", "type": "Function", "lineno": 235}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_get_feedback_for_invalid_version", "type": "Function", "lineno": 265}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_get_feedback_for_player", "type": "Function", "lineno": 271}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_search_feedback", "type": "Function", "lineno": 292}]}, {"nodeid": "tests/game_developer/feedback_system", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/feedback_system/test_analysis.py", "type": "Module"}, {"nodeid": "tests/game_developer/feedback_system/test_database.py", "type": "Module"}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py", "type": "Module"}]}, {"nodeid": "tests/game_developer/integration/test_game_development_workflow.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/integration/test_game_development_workflow.py::test_complete_game_development_cycle", "type": "Function", "lineno": 110}, {"nodeid": "tests/game_developer/integration/test_game_development_workflow.py::test_milestone_annotations", "type": "Function", "lineno": 368}, {"nodeid": "tests/game_developer/integration/test_game_development_workflow.py::test_platform_specific_features", "type": "Function", "lineno": 422}, {"nodeid": "tests/game_developer/integration/test_game_development_workflow.py::test_configuration_management_across_platforms", "type": "Function", "lineno": 487}]}, {"nodeid": "tests/game_developer/integration", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/integration/test_game_development_workflow.py", "type": "Module"}]}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_create_milestone", "type": "Function", "lineno": 137}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_create_milestone_no_backup_engine", "type": "Function", "lineno": 175}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_get_milestone", "type": "Function", "lineno": 227}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_get_nonexistent_milestone", "type": "Function", "lineno": 259}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_update_milestone_annotations", "type": "Function", "lineno": 265}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_update_nonexistent_milestone", "type": "Function", "lineno": 303}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_list_milestones", "type": "Function", "lineno": 309}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_restore_milestone", "type": "Function", "lineno": 350}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_restore_without_backup_engine", "type": "Function", "lineno": 374}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_compare_milestones", "type": "Function", "lineno": 383}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_compare_with_annotation_changes", "type": "Function", "lineno": 404}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_delete_milestone", "type": "Function", "lineno": 453}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_get_milestone_timeline", "type": "Function", "lineno": 481}]}, {"nodeid": "tests/game_developer/milestone_management", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/milestone_management/test_manager.py", "type": "Module"}]}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_initial_backup_performance[100-100]", "type": "Function", "lineno": 139}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_initial_backup_performance[500-200]", "type": "Function", "lineno": 139}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_incremental_backup_performance", "type": "Function", "lineno": 183}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_asset_optimization_efficiency", "type": "Function", "lineno": 216}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_build_feedback_correlation_performance", "type": "Function", "lineno": 253}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_milestone_snapshot_performance", "type": "Function", "lineno": 311}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_platform_config_comparison_performance", "type": "Function", "lineno": 351}]}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_playtest_event_recording_performance", "type": "Function", "lineno": 38}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_checkpoint_storage_performance", "type": "Function", "lineno": 99}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_playtest_analysis_performance", "type": "Function", "lineno": 141}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_high_frequency_event_recording", "type": "Function", "lineno": 225}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_large_batch_processing", "type": "Function", "lineno": 287}]}, {"nodeid": "tests/game_developer/performance", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/performance/test_backup_performance.py", "type": "Module"}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py", "type": "Module"}]}, {"nodeid": "tests/game_developer/platform_config/test_manager.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/platform_config/test_manager.py::test_save_and_get_config", "type": "Function", "lineno": 84}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_list_platforms", "type": "Function", "lineno": 107}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_list_versions", "type": "Function", "lineno": 124}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_compare_configs_same_platform", "type": "Function", "lineno": 150}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_compare_configs_different_platforms", "type": "Function", "lineno": 193}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_compare_platforms", "type": "Function", "lineno": 236}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_compare_versions", "type": "Function", "lineno": 289}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_get_version_history", "type": "Function", "lineno": 337}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_delete_config", "type": "Function", "lineno": 375}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_create_config_template", "type": "Function", "lineno": 403}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_copy_config", "type": "Function", "lineno": 428}]}, {"nodeid": "tests/game_developer/platform_config", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/platform_config/test_manager.py", "type": "Module"}]}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_session_summary", "type": "Function", "lineno": 155}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_session_summary_not_found", "type": "Function", "lineno": 174}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_compare_sessions", "type": "Function", "lineno": 180}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_version_statistics", "type": "Function", "lineno": 203}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_version_statistics_no_sessions", "type": "Function", "lineno": 229}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_compare_versions", "type": "Function", "lineno": 239}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_player_statistics", "type": "Function", "lineno": 279}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_player_statistics_no_sessions", "type": "Function", "lineno": 313}]}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_start_session", "type": "Function", "lineno": 21}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_end_session", "type": "Function", "lineno": 43}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_record_event", "type": "Function", "lineno": 64}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_update_metrics", "type": "Function", "lineno": 101}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_save_and_get_checkpoint", "type": "Function", "lineno": 126}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_list_sessions", "type": "Function", "lineno": 167}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_delete_session", "type": "Function", "lineno": 193}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_get_analyzer", "type": "Function", "lineno": 216}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_active_session_buffering", "type": "Function", "lineno": 223}]}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_save_and_get_session", "type": "Function", "lineno": 52}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_delete_session", "type": "Function", "lineno": 76}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_list_sessions", "type": "Function", "lineno": 96}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_save_and_get_checkpoint", "type": "Function", "lineno": 181}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_save_checkpoint_invalid_session", "type": "Function", "lineno": 209}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_list_checkpoints", "type": "Function", "lineno": 219}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_add_event_to_session", "type": "Function", "lineno": 242}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_update_session_metrics", "type": "Function", "lineno": 265}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_mark_session_completed", "type": "Function", "lineno": 288}]}, {"nodeid": "tests/game_developer/playtest_recorder", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py", "type": "Module"}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py", "type": "Module"}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py", "type": "Module"}]}, {"nodeid": "tests/game_developer", "outcome": "passed", "result": [{"nodeid": "tests/game_developer/asset_optimization", "type": "Package"}, {"nodeid": "tests/game_developer/backup_engine", "type": "Package"}, {"nodeid": "tests/game_developer/feedback_system", "type": "Package"}, {"nodeid": "tests/game_developer/integration", "type": "Package"}, {"nodeid": "tests/game_developer/milestone_management", "type": "Package"}, {"nodeid": "tests/game_developer/performance", "type": "Package"}, {"nodeid": "tests/game_developer/platform_config", "type": "Package"}, {"nodeid": "tests/game_developer/playtest_recorder", "type": "Package"}]}, {"nodeid": "tests", "outcome": "passed", "result": [{"nodeid": "tests/digital_artist", "type": "Package"}, {"nodeid": "tests/game_developer", "type": "Package"}]}], "tests": [{"nodeid": "tests/digital_artist/test_asset_tracker.py::test_scan_project", "lineno": 13, "outcome": "failed", "keywords": ["test_scan_project", "test_asset_tracker.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.007061807904392481, "outcome": "passed"}, "call": {"duration": 0.0004605669528245926, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_asset_tracker.py", "lineno": 21, "message": "TypeError: argument of type 'ReferenceMap' is not iterable"}, "traceback": [{"path": "tests/digital_artist/test_asset_tracker.py", "lineno": 21, "message": "TypeError"}], "longrepr": "asset_tracker = <creative_vault.asset_tracker.reference_tracker.CreativeAssetReferenceTracker object at 0x7f974ea21840>\ntest_project_dir = PosixPath('/tmp/tmpjzqhtm3p/test_project')\n\n    def test_scan_project(asset_tracker, test_project_dir):\n        \"\"\"Test scanning a project to identify assets and references.\"\"\"\n        # Scan the project\n        result = asset_tracker.scan_project(test_project_dir)\n    \n        # Check the result\n        assert result is not None\n>       assert \"project_path\" in result\nE       TypeError: argument of type 'ReferenceMap' is not iterable\n\ntests/digital_artist/test_asset_tracker.py:21: TypeError"}, "teardown": {"duration": 0.000569384079426527, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_asset_tracker.py::test_get_referenced_assets", "lineno": 42, "outcome": "passed", "keywords": ["test_get_referenced_assets", "test_asset_tracker.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0028807776980102062, "outcome": "passed"}, "call": {"duration": 0.000860678032040596, "outcome": "passed"}, "teardown": {"duration": 0.0005020732060074806, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_asset_tracker.py::test_asset_deduplication", "lineno": 55, "outcome": "passed", "keywords": ["test_asset_deduplication", "test_asset_tracker.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0027138544246554375, "outcome": "passed"}, "call": {"duration": 0.0026797628961503506, "outcome": "passed"}, "teardown": {"duration": 0.0005873912014067173, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_asset_tracker.py::test_update_reference", "lineno": 102, "outcome": "passed", "keywords": ["test_update_reference", "test_asset_tracker.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.002668738830834627, "outcome": "passed"}, "call": {"duration": 0.001017782837152481, "outcome": "passed"}, "teardown": {"duration": 0.0005220533348619938, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_asset_tracker.py::test_error_handling_for_nonexistent_files", "lineno": 135, "outcome": "passed", "keywords": ["test_error_handling_for_nonexistent_files", "test_asset_tracker.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.00038800109177827835, "outcome": "passed"}, "call": {"duration": 0.00026289792731404305, "outcome": "passed"}, "teardown": {"duration": 0.00024940306320786476, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_initialize_repository", "lineno": 14, "outcome": "failed", "keywords": ["test_initialize_repository", "test_backup_engine.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0002569570206105709, "outcome": "passed"}, "call": {"duration": 0.0009764037095010281, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_backup_engine.py", "lineno": 26, "message": "assert False is True"}, "traceback": [{"path": "tests/digital_artist/test_backup_engine.py", "lineno": 26, "message": "AssertionError"}], "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n", "longrepr": "temp_dir = PosixPath('/tmp/tmpwdg7yo3h')\n\n    def test_initialize_repository(temp_dir):\n        \"\"\"Test initializing a new backup repository.\"\"\"\n        # Create a backup engine\n        repo_path = temp_dir / \"test_repo\"\n        config = BackupConfig(repository_path=repo_path)\n        engine = DeltaBackupEngine(config)\n    \n        # Initialize the repository\n        result = engine.initialize_repository(repo_path)\n    \n        # Check the result\n>       assert result is True\nE       assert False is True\n\ntests/digital_artist/test_backup_engine.py:26: AssertionError"}, "teardown": {"duration": 0.00045916391536593437, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_create_snapshot", "lineno": 35, "outcome": "failed", "keywords": ["test_create_snapshot", "test_backup_engine.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.003185826353728771, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.007038210052996874, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_backup_engine.py", "lineno": 43, "message": "AssertionError: assert False\n +  where False = <built-in method startswith of str object at 0x7f974e939110>('snapshot-')\n +    where <built-in method startswith of str object at 0x7f974e939110> = 'snapshot_20250616_042717_819325'.startswith"}, "traceback": [{"path": "tests/digital_artist/test_backup_engine.py", "lineno": 43, "message": "AssertionError"}], "longrepr": "backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e963430>\ntest_project_dir = PosixPath('/tmp/tmpnxn15u70/test_project')\n\n    def test_create_snapshot(backup_engine, test_project_dir):\n        \"\"\"Test creating a snapshot of a project directory.\"\"\"\n        # Create a snapshot\n        snapshot_id = backup_engine.create_snapshot(test_project_dir)\n    \n        # Check that the snapshot was created\n        assert snapshot_id is not None\n>       assert snapshot_id.startswith(\"snapshot-\")\nE       AssertionError: assert False\nE        +  where False = <built-in method startswith of str object at 0x7f974e939110>('snapshot-')\nE        +    where <built-in method startswith of str object at 0x7f974e939110> = 'snapshot_20250616_042717_819325'.startswith\n\ntests/digital_artist/test_backup_engine.py:43: AssertionError"}, "teardown": {"duration": 0.0009830128401517868, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_restore_snapshot", "lineno": 52, "outcome": "failed", "keywords": ["test_restore_snapshot", "test_backup_engine.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.00327529339119792, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.0036151218228042126, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_backup_engine.py", "lineno": 65, "message": "assert False is True"}, "traceback": [{"path": "tests/digital_artist/test_backup_engine.py", "lineno": 65, "message": "AssertionError"}], "stdout": "Error restoring snapshot snapshot_20250616_042717_833757: Failed to restore snapshot snapshot_20250616_042717_833757: 'dict' object has no attribute 'files'\n", "longrepr": "backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e936260>\ntest_project_dir = PosixPath('/tmp/tmprp6t4yj4/test_project')\ntemp_dir = PosixPath('/tmp/tmprp6t4yj4')\n\n    def test_restore_snapshot(backup_engine, test_project_dir, temp_dir):\n        \"\"\"Test restoring a snapshot to a directory.\"\"\"\n        # Create a snapshot\n        snapshot_id = backup_engine.create_snapshot(test_project_dir)\n    \n        # Create a target directory for restoration\n        target_dir = temp_dir / \"restored_project\"\n    \n        # Restore the snapshot\n        result = backup_engine.restore_snapshot(snapshot_id, target_dir)\n    \n        # Check the result\n>       assert result is True\nE       assert False is True\n\ntests/digital_artist/test_backup_engine.py:65: AssertionError"}, "teardown": {"duration": 0.0009998292662203312, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_get_snapshot_info", "lineno": 78, "outcome": "passed", "keywords": ["test_get_snapshot_info", "test_backup_engine.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0032636402174830437, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.0034226523712277412, "outcome": "passed"}, "teardown": {"duration": 0.0009289830923080444, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_list_snapshots", "lineno": 98, "outcome": "passed", "keywords": ["test_list_snapshots", "test_backup_engine.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.003160407766699791, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.003500139806419611, "outcome": "passed", "stdout": "Error reading unified snapshots: Failed to list snapshots: 'dict' object has no attribute 'timestamp'\n"}, "teardown": {"duration": 0.0009546778164803982, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_backup_engine.py::test_incremental_backup", "lineno": 115, "outcome": "failed", "keywords": ["test_incremental_backup", "test_backup_engine.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.003209081944078207, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.007739483844488859, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_backup_engine.py", "lineno": 136, "message": "AssertionError: assert 6 == 1\n +  where 6 = len(['/tmp/tmpqxx3tvhy/test_project/project.txt', '/tmp/tmpqxx3tvhy/test_project/new_file.txt', '/tmp/tmpqxx3tvhy/test_pro...es/texture1.png', '/tmp/tmpqxx3tvhy/test_project/images/image1.png', '/tmp/tmpqxx3tvhy/test_project/images/image2.png'])"}, "traceback": [{"path": "tests/digital_artist/test_backup_engine.py", "lineno": 136, "message": "AssertionError"}], "stdout": "Error reading unified snapshots: Failed to list snapshots: 'dict' object has no attribute 'timestamp'\n", "longrepr": "backup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e960c10>\ntest_project_dir = PosixPath('/tmp/tmpqxx3tvhy/test_project')\n\n    def test_incremental_backup(backup_engine, test_project_dir):\n        \"\"\"Test incremental backup with modified files.\"\"\"\n        # Create an initial snapshot\n        snapshot_id_1 = backup_engine.create_snapshot(test_project_dir)\n    \n        # Modify a file in the project\n        with open(test_project_dir / \"project.txt\", \"a\") as f:\n            f.write(\"This is a new line added to test incremental backup.\\n\")\n    \n        # Create a new file\n        with open(test_project_dir / \"new_file.txt\", \"w\") as f:\n            f.write(\"This is a new file added to test incremental backup.\\n\")\n    \n        # Create a second snapshot\n        snapshot_id_2 = backup_engine.create_snapshot(test_project_dir)\n    \n        # Get info about the second snapshot\n        snapshot_info = backup_engine.get_snapshot_info(snapshot_id_2)\n    \n        # Check that only the modified and new files are included\n>       assert len(snapshot_info[\"new_files\"]) == 1  # The new file\nE       AssertionError: assert 6 == 1\nE        +  where 6 = len(['/tmp/tmpqxx3tvhy/test_project/project.txt', '/tmp/tmpqxx3tvhy/test_project/new_file.txt', '/tmp/tmpqxx3tvhy/test_pro...es/texture1.png', '/tmp/tmpqxx3tvhy/test_project/images/image1.png', '/tmp/tmpqxx3tvhy/test_project/images/image2.png'])\n\ntests/digital_artist/test_backup_engine.py:136: AssertionError"}, "teardown": {"duration": 0.0011620782315731049, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_list_elements_for_image", "lineno": 13, "outcome": "passed", "keywords": ["test_list_elements_for_image", "test_element_extraction.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0004930938594043255, "outcome": "passed"}, "call": {"duration": 0.00029795896261930466, "outcome": "passed"}, "teardown": {"duration": 0.0002858256921172142, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_extract_whole_image", "lineno": 33, "outcome": "passed", "keywords": ["test_extract_whole_image", "test_element_extraction.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0004659658297896385, "outcome": "passed"}, "call": {"duration": 0.005333472974598408, "outcome": "passed"}, "teardown": {"duration": 0.0003003748133778572, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_extract_image_region", "lineno": 58, "outcome": "passed", "keywords": ["test_extract_image_region", "test_element_extraction.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0004753326065838337, "outcome": "passed"}, "call": {"duration": 0.002823722083121538, "outcome": "passed"}, "teardown": {"duration": 0.00030955811962485313, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_replace_image_region", "lineno": 87, "outcome": "passed", "keywords": ["test_replace_image_region", "test_element_extraction.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0004671262577176094, "outcome": "passed"}, "call": {"duration": 0.006346754729747772, "outcome": "passed"}, "teardown": {"duration": 0.00030988501384854317, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_list_elements_for_3d_model", "lineno": 122, "outcome": "passed", "keywords": ["test_list_elements_for_3d_model", "test_element_extraction.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0004820008762180805, "outcome": "passed"}, "call": {"duration": 0.0012334128841757774, "outcome": "passed"}, "teardown": {"duration": 0.0003217230550944805, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_extract_whole_model", "lineno": 138, "outcome": "passed", "keywords": ["test_extract_whole_model", "test_element_extraction.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0004893820732831955, "outcome": "passed"}, "call": {"duration": 0.003182703163474798, "outcome": "passed"}, "teardown": {"duration": 0.0003379508852958679, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_error_handling_for_invalid_element", "lineno": 161, "outcome": "passed", "keywords": ["test_error_handling_for_invalid_element", "test_element_extraction.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0004902719520032406, "outcome": "passed"}, "call": {"duration": 0.00032045878469944, "outcome": "passed"}, "teardown": {"duration": 0.0002794358879327774, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_element_extraction.py::test_error_handling_for_nonexistent_file", "lineno": 168, "outcome": "passed", "keywords": ["test_error_handling_for_nonexistent_file", "test_element_extraction.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.00032186415046453476, "outcome": "passed"}, "call": {"duration": 0.00020194891840219498, "outcome": "passed"}, "teardown": {"duration": 0.00023578573018312454, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_integration.py::test_full_backup_restore_workflow", "lineno": 14, "outcome": "failed", "keywords": ["test_full_backup_restore_workflow", "test_integration.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0025287973694503307, "outcome": "passed"}, "call": {"duration": 0.00540449284017086, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_integration.py", "lineno": 34, "message": "assert False is True"}, "traceback": [{"path": "tests/digital_artist/test_integration.py", "lineno": 34, "message": "AssertionError"}], "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\nError restoring snapshot snapshot_20250616_042717_906679: Failed to restore snapshot snapshot_20250616_042717_906679: 'dict' object has no attribute 'files'\n", "longrepr": "temp_dir = PosixPath('/tmp/tmp2uyj30in')\ntest_project_dir = PosixPath('/tmp/tmp2uyj30in/test_project')\n\n    def test_full_backup_restore_workflow(temp_dir, test_project_dir):\n        \"\"\"Test the complete backup and restore workflow.\"\"\"\n        # Initialize CreativeVault\n        vault = CreativeVault(repository_path=temp_dir / \"repo\")\n    \n        # Create a backup of the test project\n        backup_result = vault.backup_project(test_project_dir)\n    \n        # Check the backup result\n        assert \"snapshot_id\" in backup_result\n        snapshot_id = backup_result[\"snapshot_id\"]\n    \n        # Create a target directory for restoration\n        restore_dir = temp_dir / \"restored_project\"\n    \n        # Restore the backup\n        restore_result = vault.restore_project(snapshot_id, restore_dir)\n    \n        # Check the restore result\n>       assert restore_result[\"success\"] is True\nE       assert False is True\n\ntests/digital_artist/test_integration.py:34: AssertionError"}, "teardown": {"duration": 0.001072647050023079, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_integration.py::test_version_comparison_workflow", "lineno": 46, "outcome": "failed", "keywords": ["test_version_comparison_workflow", "test_integration.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.002641703002154827, "outcome": "passed"}, "call": {"duration": 0.01516217878088355, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError: File /tmp/tmpgj5ik7bk/test_project/images/test_comparison.png not found in snapshot snapshot_20250616_042717_926705"}, "traceback": [{"path": "tests/digital_artist/test_integration.py", "lineno": 71, "message": ""}, {"path": "creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError"}], "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\nWarning: Failed to generate thumbnail for ver-1750048037926_927436: Object file not found for version ver-1750048037926_927436\nError reading unified snapshots: Failed to list snapshots: 'dict' object has no attribute 'timestamp'\n", "longrepr": "temp_dir = PosixPath('/tmp/tmpgj5ik7bk')\ntest_project_dir = PosixPath('/tmp/tmpgj5ik7bk/test_project')\ntest_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')\ntest_image_modified = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image_modified.png')\n\n    def test_version_comparison_workflow(temp_dir, test_project_dir, test_image, test_image_modified):\n        \"\"\"Test the version comparison workflow.\"\"\"\n        # Initialize CreativeVault\n        vault = CreativeVault(repository_path=temp_dir / \"repo\")\n    \n        # Create an image to track in the project directory\n        image_path = test_project_dir / \"images\" / \"test_comparison.png\"\n        shutil.copy(test_image, image_path)\n    \n        # Create an initial backup\n        backup_result = vault.backup_project(test_project_dir)\n        snapshot_id_1 = backup_result[\"snapshot_id\"]\n    \n        # Initialize the timeline for an image file\n        version_id_1 = vault.timeline_manager.register_version(image_path, snapshot_id_1)\n    \n        # Replace with the modified image instead of modifying at runtime\n        shutil.copy(test_image_modified, image_path)\n    \n        # Create a second backup\n        backup_result = vault.backup_project(test_project_dir)\n        snapshot_id_2 = backup_result[\"snapshot_id\"]\n    \n        # Register the second version\n>       version_id_2 = vault.timeline_manager.register_version(image_path, snapshot_id_2)\n\ntests/digital_artist/test_integration.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974eacf970>\nfile_path = PosixPath('/tmp/tmpgj5ik7bk/test_project/images/test_comparison.png')\nsnapshot_id = 'snapshot_20250616_042717_926705', metadata = None\n\n    def register_version(\n        self,\n        file_path: Path,\n        snapshot_id: str,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"Register a new version of a file in the timeline.\n    \n        Args:\n            file_path: Path to the file\n            snapshot_id: ID of the snapshot containing this version\n            metadata: Optional metadata about this version\n    \n        Returns:\n            str: Unique version ID\n    \n        Raises:\n            ValueError: If the snapshot does not exist\n        \"\"\"\n        snapshot_path = self.snapshots_path / snapshot_id\n        if not snapshot_path.exists():\n            raise ValueError(f\"Snapshot {snapshot_id} does not exist\")\n    \n        # Create a unique version ID\n        version_id = create_unique_id(\"ver-\")\n    \n        # Get the snapshot manifest to find the file\n        manifest_path = snapshot_path / \"manifest.json\"\n        try:\n            manifest = load_json(manifest_path)\n        except Exception as e:\n            raise ValueError(f\"Failed to load snapshot manifest: {e}\")\n    \n        # Try to find the file in the manifest using different path formats\n        # First try the original path as-is\n        relative_path = str(file_path)\n        if relative_path not in manifest[\"files\"]:\n            # Try using just the filename\n            file_name = file_path.name\n            matching_paths = [path for path in manifest[\"files\"].keys() if path.endswith(file_name)]\n            if matching_paths:\n                relative_path = matching_paths[0]\n            else:\n                # If still not found, fail with a clear error\n>               raise ValueError(f\"File {relative_path} not found in snapshot {snapshot_id}\")\nE               ValueError: File /tmp/tmpgj5ik7bk/test_project/images/test_comparison.png not found in snapshot snapshot_20250616_042717_926705\n\ncreative_vault/timeline/timeline_manager.py:107: ValueError"}, "teardown": {"duration": 0.0012553520500659943, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_integration.py::test_element_extraction_workflow", "lineno": 91, "outcome": "passed", "keywords": ["test_element_extraction_workflow", "test_integration.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0026649320498108864, "outcome": "passed"}, "call": {"duration": 0.005825409200042486, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "teardown": {"duration": 0.0008009900338947773, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_integration.py::test_asset_deduplication_workflow", "lineno": 121, "outcome": "passed", "keywords": ["test_asset_deduplication_workflow", "test_integration.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.00028160400688648224, "outcome": "passed"}, "call": {"duration": 0.0064557818695902824, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "teardown": {"duration": 0.0008076010271906853, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_integration.py::test_multi_snapshot_timeline", "lineno": 168, "outcome": "failed", "keywords": ["test_multi_snapshot_timeline", "test_integration.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.002581984270364046, "outcome": "passed"}, "call": {"duration": 0.006527233868837357, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError: File /tmp/tmpv8fq7507/test_project/test_tracked_image.png not found in snapshot snapshot_20250616_042717_969772"}, "traceback": [{"path": "tests/digital_artist/test_integration.py", "lineno": 186, "message": ""}, {"path": "creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError"}], "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n", "longrepr": "temp_dir = PosixPath('/tmp/tmpv8fq7507')\ntest_project_dir = PosixPath('/tmp/tmpv8fq7507/test_project')\n\n    def test_multi_snapshot_timeline(temp_dir, test_project_dir):\n        \"\"\"Test creating multiple snapshots and tracking a file's timeline.\"\"\"\n        # Initialize CreativeVault\n        vault = CreativeVault(repository_path=temp_dir / \"repo\")\n    \n        # Create a test image to track\n        target_image = test_project_dir / \"test_tracked_image.png\"\n    \n        # Create the initial image\n        img = Image.new('RGB', (200, 200), color=(0, 0, 255))\n        img.save(target_image)\n    \n        # Create the first backup\n        backup_result_1 = vault.backup_project(test_project_dir)\n        snapshot_id_1 = backup_result_1[\"snapshot_id\"]\n    \n        # Register the first version of a file\n>       version_id_1 = vault.timeline_manager.register_version(target_image, snapshot_id_1)\n\ntests/digital_artist/test_integration.py:186: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974eacdff0>\nfile_path = PosixPath('/tmp/tmpv8fq7507/test_project/test_tracked_image.png')\nsnapshot_id = 'snapshot_20250616_042717_969772', metadata = None\n\n    def register_version(\n        self,\n        file_path: Path,\n        snapshot_id: str,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"Register a new version of a file in the timeline.\n    \n        Args:\n            file_path: Path to the file\n            snapshot_id: ID of the snapshot containing this version\n            metadata: Optional metadata about this version\n    \n        Returns:\n            str: Unique version ID\n    \n        Raises:\n            ValueError: If the snapshot does not exist\n        \"\"\"\n        snapshot_path = self.snapshots_path / snapshot_id\n        if not snapshot_path.exists():\n            raise ValueError(f\"Snapshot {snapshot_id} does not exist\")\n    \n        # Create a unique version ID\n        version_id = create_unique_id(\"ver-\")\n    \n        # Get the snapshot manifest to find the file\n        manifest_path = snapshot_path / \"manifest.json\"\n        try:\n            manifest = load_json(manifest_path)\n        except Exception as e:\n            raise ValueError(f\"Failed to load snapshot manifest: {e}\")\n    \n        # Try to find the file in the manifest using different path formats\n        # First try the original path as-is\n        relative_path = str(file_path)\n        if relative_path not in manifest[\"files\"]:\n            # Try using just the filename\n            file_name = file_path.name\n            matching_paths = [path for path in manifest[\"files\"].keys() if path.endswith(file_name)]\n            if matching_paths:\n                relative_path = matching_paths[0]\n            else:\n                # If still not found, fail with a clear error\n>               raise ValueError(f\"File {relative_path} not found in snapshot {snapshot_id}\")\nE               ValueError: File /tmp/tmpv8fq7507/test_project/test_tracked_image.png not found in snapshot snapshot_20250616_042717_969772\n\ncreative_vault/timeline/timeline_manager.py:107: ValueError"}, "teardown": {"duration": 0.0011248672381043434, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_register_version", "lineno": 35, "outcome": "failed", "keywords": ["test_register_version", "TestTimelineManager", "test_timeline_manager.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.003517360892146826, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.005246858112514019, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError: File /tmp/tmpc_o0qfvh/test_project/test_image.png not found in snapshot snapshot_20250616_042717_990020"}, "traceback": [{"path": "tests/digital_artist/test_timeline_manager.py", "lineno": 46, "message": ""}, {"path": "creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError"}], "longrepr": "self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed136d0>\nbackup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e937580>\ntimeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e936ad0>\ntest_project_dir = PosixPath('/tmp/tmpc_o0qfvh/test_project')\ntest_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')\n\n    def test_register_version(self, backup_engine, timeline_manager, test_project_dir, test_image):\n        \"\"\"Test registering a version of a file in the timeline.\"\"\"\n        # First ensure the test image is in the test project directory\n        target_path = test_project_dir / \"test_image.png\"\n        shutil.copy(test_image, target_path)\n    \n        # Create a snapshot that includes the image\n        snapshot_id = backup_engine.create_snapshot(test_project_dir)\n    \n        # Register a version\n>       version_id = timeline_manager.register_version(target_path, snapshot_id)\n\ntests/digital_artist/test_timeline_manager.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e936ad0>\nfile_path = PosixPath('/tmp/tmpc_o0qfvh/test_project/test_image.png')\nsnapshot_id = 'snapshot_20250616_042717_990020', metadata = None\n\n    def register_version(\n        self,\n        file_path: Path,\n        snapshot_id: str,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"Register a new version of a file in the timeline.\n    \n        Args:\n            file_path: Path to the file\n            snapshot_id: ID of the snapshot containing this version\n            metadata: Optional metadata about this version\n    \n        Returns:\n            str: Unique version ID\n    \n        Raises:\n            ValueError: If the snapshot does not exist\n        \"\"\"\n        snapshot_path = self.snapshots_path / snapshot_id\n        if not snapshot_path.exists():\n            raise ValueError(f\"Snapshot {snapshot_id} does not exist\")\n    \n        # Create a unique version ID\n        version_id = create_unique_id(\"ver-\")\n    \n        # Get the snapshot manifest to find the file\n        manifest_path = snapshot_path / \"manifest.json\"\n        try:\n            manifest = load_json(manifest_path)\n        except Exception as e:\n            raise ValueError(f\"Failed to load snapshot manifest: {e}\")\n    \n        # Try to find the file in the manifest using different path formats\n        # First try the original path as-is\n        relative_path = str(file_path)\n        if relative_path not in manifest[\"files\"]:\n            # Try using just the filename\n            file_name = file_path.name\n            matching_paths = [path for path in manifest[\"files\"].keys() if path.endswith(file_name)]\n            if matching_paths:\n                relative_path = matching_paths[0]\n            else:\n                # If still not found, fail with a clear error\n>               raise ValueError(f\"File {relative_path} not found in snapshot {snapshot_id}\")\nE               ValueError: File /tmp/tmpc_o0qfvh/test_project/test_image.png not found in snapshot snapshot_20250616_042717_990020\n\ncreative_vault/timeline/timeline_manager.py:107: ValueError"}, "teardown": {"duration": 0.0011251573450863361, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_get_file_timeline", "lineno": 57, "outcome": "failed", "keywords": ["test_get_file_timeline", "TestTimelineManager", "test_timeline_manager.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0034959609620273113, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.005220415070652962, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError: File /tmp/tmpnt00d7rp/test_project/test_image.png not found in snapshot snapshot_20250616_042718_010163"}, "traceback": [{"path": "tests/digital_artist/test_timeline_manager.py", "lineno": 68, "message": ""}, {"path": "creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError"}], "longrepr": "self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed139a0>\nbackup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e7ef610>\ntimeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e7ee050>\ntest_project_dir = PosixPath('/tmp/tmpnt00d7rp/test_project')\ntest_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')\n\n    def test_get_file_timeline(self, backup_engine, timeline_manager, test_project_dir, test_image):\n        \"\"\"Test getting the timeline of versions for a file.\"\"\"\n        # Copy the test image to the test project directory\n        target_path = test_project_dir / \"test_image.png\"\n        shutil.copy(test_image, target_path)\n    \n        # Create a snapshot\n        snapshot_id = backup_engine.create_snapshot(test_project_dir)\n    \n        # Register a version\n>       version_id = timeline_manager.register_version(target_path, snapshot_id)\n\ntests/digital_artist/test_timeline_manager.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e7ee050>\nfile_path = PosixPath('/tmp/tmpnt00d7rp/test_project/test_image.png')\nsnapshot_id = 'snapshot_20250616_042718_010163', metadata = None\n\n    def register_version(\n        self,\n        file_path: Path,\n        snapshot_id: str,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"Register a new version of a file in the timeline.\n    \n        Args:\n            file_path: Path to the file\n            snapshot_id: ID of the snapshot containing this version\n            metadata: Optional metadata about this version\n    \n        Returns:\n            str: Unique version ID\n    \n        Raises:\n            ValueError: If the snapshot does not exist\n        \"\"\"\n        snapshot_path = self.snapshots_path / snapshot_id\n        if not snapshot_path.exists():\n            raise ValueError(f\"Snapshot {snapshot_id} does not exist\")\n    \n        # Create a unique version ID\n        version_id = create_unique_id(\"ver-\")\n    \n        # Get the snapshot manifest to find the file\n        manifest_path = snapshot_path / \"manifest.json\"\n        try:\n            manifest = load_json(manifest_path)\n        except Exception as e:\n            raise ValueError(f\"Failed to load snapshot manifest: {e}\")\n    \n        # Try to find the file in the manifest using different path formats\n        # First try the original path as-is\n        relative_path = str(file_path)\n        if relative_path not in manifest[\"files\"]:\n            # Try using just the filename\n            file_name = file_path.name\n            matching_paths = [path for path in manifest[\"files\"].keys() if path.endswith(file_name)]\n            if matching_paths:\n                relative_path = matching_paths[0]\n            else:\n                # If still not found, fail with a clear error\n>               raise ValueError(f\"File {relative_path} not found in snapshot {snapshot_id}\")\nE               ValueError: File /tmp/tmpnt00d7rp/test_project/test_image.png not found in snapshot snapshot_20250616_042718_010163\n\ncreative_vault/timeline/timeline_manager.py:107: ValueError"}, "teardown": {"duration": 0.0011209193617105484, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_generate_thumbnail", "lineno": 86, "outcome": "failed", "keywords": ["test_generate_thumbnail", "TestTimelineManager", "test_timeline_manager.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0035146037116646767, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.005237955134361982, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError: File /tmp/tmp1pzm0tyv/test_project/test_image.png not found in snapshot snapshot_20250616_042718_030327"}, "traceback": [{"path": "tests/digital_artist/test_timeline_manager.py", "lineno": 97, "message": ""}, {"path": "creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError"}], "longrepr": "self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed13c70>\nbackup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e842fb0>\ntimeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e842e90>\ntest_project_dir = PosixPath('/tmp/tmp1pzm0tyv/test_project')\ntest_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')\n\n    def test_generate_thumbnail(self, backup_engine, timeline_manager, test_project_dir, test_image):\n        \"\"\"Test generating a thumbnail preview for a version.\"\"\"\n        # Copy the test image to the test project directory\n        target_path = test_project_dir / \"test_image.png\"\n        shutil.copy(test_image, target_path)\n    \n        # Create a snapshot\n        snapshot_id = backup_engine.create_snapshot(test_project_dir)\n    \n        # Register a version\n>       version_id = timeline_manager.register_version(target_path, snapshot_id)\n\ntests/digital_artist/test_timeline_manager.py:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e842e90>\nfile_path = PosixPath('/tmp/tmp1pzm0tyv/test_project/test_image.png')\nsnapshot_id = 'snapshot_20250616_042718_030327', metadata = None\n\n    def register_version(\n        self,\n        file_path: Path,\n        snapshot_id: str,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"Register a new version of a file in the timeline.\n    \n        Args:\n            file_path: Path to the file\n            snapshot_id: ID of the snapshot containing this version\n            metadata: Optional metadata about this version\n    \n        Returns:\n            str: Unique version ID\n    \n        Raises:\n            ValueError: If the snapshot does not exist\n        \"\"\"\n        snapshot_path = self.snapshots_path / snapshot_id\n        if not snapshot_path.exists():\n            raise ValueError(f\"Snapshot {snapshot_id} does not exist\")\n    \n        # Create a unique version ID\n        version_id = create_unique_id(\"ver-\")\n    \n        # Get the snapshot manifest to find the file\n        manifest_path = snapshot_path / \"manifest.json\"\n        try:\n            manifest = load_json(manifest_path)\n        except Exception as e:\n            raise ValueError(f\"Failed to load snapshot manifest: {e}\")\n    \n        # Try to find the file in the manifest using different path formats\n        # First try the original path as-is\n        relative_path = str(file_path)\n        if relative_path not in manifest[\"files\"]:\n            # Try using just the filename\n            file_name = file_path.name\n            matching_paths = [path for path in manifest[\"files\"].keys() if path.endswith(file_name)]\n            if matching_paths:\n                relative_path = matching_paths[0]\n            else:\n                # If still not found, fail with a clear error\n>               raise ValueError(f\"File {relative_path} not found in snapshot {snapshot_id}\")\nE               ValueError: File /tmp/tmp1pzm0tyv/test_project/test_image.png not found in snapshot snapshot_20250616_042718_030327\n\ncreative_vault/timeline/timeline_manager.py:107: ValueError"}, "teardown": {"duration": 0.0011110231280326843, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_compare_versions", "lineno": 112, "outcome": "failed", "keywords": ["test_compare_versions", "TestTimelineManager", "test_timeline_manager.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0035683568567037582, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.005229231435805559, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError: File /tmp/tmpx1uoqsam/test_project/test_image.png not found in snapshot snapshot_20250616_042718_050185"}, "traceback": [{"path": "tests/digital_artist/test_timeline_manager.py", "lineno": 124, "message": ""}, {"path": "creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError"}], "longrepr": "self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed13f70>\nbackup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e811060>\ntimeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e812860>\ntest_project_dir = PosixPath('/tmp/tmpx1uoqsam/test_project')\ntest_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')\ntest_image_modified = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image_modified.png')\n\n    def test_compare_versions(self, backup_engine, timeline_manager, test_project_dir,\n                             test_image, test_image_modified):\n        \"\"\"Test comparing two versions of a file.\"\"\"\n        # Copy the test image to the test project directory\n        target_path = test_project_dir / \"test_image.png\"\n        shutil.copy(test_image, target_path)\n    \n        # Create an initial snapshot\n        snapshot_id_1 = backup_engine.create_snapshot(test_project_dir)\n    \n        # Register the first version\n>       version_id_1 = timeline_manager.register_version(target_path, snapshot_id_1)\n\ntests/digital_artist/test_timeline_manager.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e812860>\nfile_path = PosixPath('/tmp/tmpx1uoqsam/test_project/test_image.png')\nsnapshot_id = 'snapshot_20250616_042718_050185', metadata = None\n\n    def register_version(\n        self,\n        file_path: Path,\n        snapshot_id: str,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"Register a new version of a file in the timeline.\n    \n        Args:\n            file_path: Path to the file\n            snapshot_id: ID of the snapshot containing this version\n            metadata: Optional metadata about this version\n    \n        Returns:\n            str: Unique version ID\n    \n        Raises:\n            ValueError: If the snapshot does not exist\n        \"\"\"\n        snapshot_path = self.snapshots_path / snapshot_id\n        if not snapshot_path.exists():\n            raise ValueError(f\"Snapshot {snapshot_id} does not exist\")\n    \n        # Create a unique version ID\n        version_id = create_unique_id(\"ver-\")\n    \n        # Get the snapshot manifest to find the file\n        manifest_path = snapshot_path / \"manifest.json\"\n        try:\n            manifest = load_json(manifest_path)\n        except Exception as e:\n            raise ValueError(f\"Failed to load snapshot manifest: {e}\")\n    \n        # Try to find the file in the manifest using different path formats\n        # First try the original path as-is\n        relative_path = str(file_path)\n        if relative_path not in manifest[\"files\"]:\n            # Try using just the filename\n            file_name = file_path.name\n            matching_paths = [path for path in manifest[\"files\"].keys() if path.endswith(file_name)]\n            if matching_paths:\n                relative_path = matching_paths[0]\n            else:\n                # If still not found, fail with a clear error\n>               raise ValueError(f\"File {relative_path} not found in snapshot {snapshot_id}\")\nE               ValueError: File /tmp/tmpx1uoqsam/test_project/test_image.png not found in snapshot snapshot_20250616_042718_050185\n\ncreative_vault/timeline/timeline_manager.py:107: ValueError"}, "teardown": {"duration": 0.0011391770094633102, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_timeline_manager.py::TestTimelineManager::test_timeline_filtering_by_time_range", "lineno": 152, "outcome": "failed", "keywords": ["test_timeline_filtering_by_time_range", "TestTimelineManager", "test_timeline_manager.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.003453594632446766, "outcome": "passed", "stdout": "Failed to initialize repository: Object of type <class 'set'> is not JSON serializable\n"}, "call": {"duration": 0.005261916201561689, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError: File /tmp/tmptjemma9m/test_project/test_image.png not found in snapshot snapshot_20250616_042718_070167"}, "traceback": [{"path": "tests/digital_artist/test_timeline_manager.py", "lineno": 164, "message": ""}, {"path": "creative_vault/timeline/timeline_manager.py", "lineno": 107, "message": "ValueError"}], "longrepr": "self = <tests.digital_artist.test_timeline_manager.TestTimelineManager object at 0x7f974ed4c280>\nbackup_engine = <creative_vault.backup_engine.incremental_backup.DeltaBackupEngine object at 0x7f974e7ee2f0>\ntimeline_manager = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e7ec430>\ntest_project_dir = PosixPath('/tmp/tmptjemma9m/test_project')\ntest_image = PosixPath('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/digital_artist/test_data/test_image.png')\n\n    def test_timeline_filtering_by_time_range(self, backup_engine, timeline_manager,\n                                             test_project_dir, test_image):\n        \"\"\"Test filtering the timeline by time range.\"\"\"\n        # Copy the test image to the test project directory\n        target_path = test_project_dir / \"test_image.png\"\n        shutil.copy(test_image, target_path)\n    \n        # Create an initial snapshot\n        snapshot_id_1 = backup_engine.create_snapshot(test_project_dir)\n    \n        # Register the first version\n>       version_id_1 = timeline_manager.register_version(target_path, snapshot_id_1)\n\ntests/digital_artist/test_timeline_manager.py:164: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <creative_vault.timeline.timeline_manager.CreativeTimelineManager object at 0x7f974e7ec430>\nfile_path = PosixPath('/tmp/tmptjemma9m/test_project/test_image.png')\nsnapshot_id = 'snapshot_20250616_042718_070167', metadata = None\n\n    def register_version(\n        self,\n        file_path: Path,\n        snapshot_id: str,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"Register a new version of a file in the timeline.\n    \n        Args:\n            file_path: Path to the file\n            snapshot_id: ID of the snapshot containing this version\n            metadata: Optional metadata about this version\n    \n        Returns:\n            str: Unique version ID\n    \n        Raises:\n            ValueError: If the snapshot does not exist\n        \"\"\"\n        snapshot_path = self.snapshots_path / snapshot_id\n        if not snapshot_path.exists():\n            raise ValueError(f\"Snapshot {snapshot_id} does not exist\")\n    \n        # Create a unique version ID\n        version_id = create_unique_id(\"ver-\")\n    \n        # Get the snapshot manifest to find the file\n        manifest_path = snapshot_path / \"manifest.json\"\n        try:\n            manifest = load_json(manifest_path)\n        except Exception as e:\n            raise ValueError(f\"Failed to load snapshot manifest: {e}\")\n    \n        # Try to find the file in the manifest using different path formats\n        # First try the original path as-is\n        relative_path = str(file_path)\n        if relative_path not in manifest[\"files\"]:\n            # Try using just the filename\n            file_name = file_path.name\n            matching_paths = [path for path in manifest[\"files\"].keys() if path.endswith(file_name)]\n            if matching_paths:\n                relative_path = matching_paths[0]\n            else:\n                # If still not found, fail with a clear error\n>               raise ValueError(f\"File {relative_path} not found in snapshot {snapshot_id}\")\nE               ValueError: File /tmp/tmptjemma9m/test_project/test_image.png not found in snapshot snapshot_20250616_042718_070167\n\ncreative_vault/timeline/timeline_manager.py:107: ValueError"}, "teardown": {"duration": 0.0013113399036228657, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_generate_image_diff", "lineno": 13, "outcome": "passed", "keywords": ["test_generate_image_diff", "test_visual_diff.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0006034183315932751, "outcome": "passed"}, "call": {"duration": 0.022740900982171297, "outcome": "passed"}, "teardown": {"duration": 0.00034182798117399216, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_generate_model_diff", "lineno": 27, "outcome": "passed", "keywords": ["test_generate_model_diff", "test_visual_diff.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0005714292638003826, "outcome": "passed"}, "call": {"duration": 0.2070639836601913, "outcome": "passed"}, "teardown": {"duration": 0.00042327307164669037, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_get_diff_stats_for_images", "lineno": 41, "outcome": "passed", "keywords": ["test_get_diff_stats_for_images", "test_visual_diff.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0006539458408951759, "outcome": "passed"}, "call": {"duration": 0.012177321128547192, "outcome": "passed"}, "teardown": {"duration": 0.0003215782344341278, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_get_diff_stats_for_models", "lineno": 62, "outcome": "passed", "keywords": ["test_get_diff_stats_for_models", "test_visual_diff.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0005623521283268929, "outcome": "passed"}, "call": {"duration": 0.0023577380925416946, "outcome": "passed"}, "teardown": {"duration": 0.0003436906263232231, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_diff_generation_with_custom_output_path", "lineno": 81, "outcome": "passed", "keywords": ["test_diff_generation_with_custom_output_path", "test_visual_diff.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0005747308023273945, "outcome": "passed"}, "call": {"duration": 0.021678918041288853, "outcome": "passed"}, "teardown": {"duration": 0.00035953475162386894, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_error_handling_for_nonexistent_files", "lineno": 98, "outcome": "passed", "keywords": ["test_error_handling_for_nonexistent_files", "test_visual_diff.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.00034910300746560097, "outcome": "passed"}, "call": {"duration": 0.0002118782140314579, "outcome": "passed"}, "teardown": {"duration": 0.00025590695440769196, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_visual_diff.py::test_diff_for_different_image_sizes", "lineno": 111, "outcome": "passed", "keywords": ["test_diff_for_different_image_sizes", "test_visual_diff.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.00032852310687303543, "outcome": "passed"}, "call": {"duration": 0.010681279934942722, "outcome": "passed"}, "teardown": {"duration": 0.0003264709375798702, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_get_supported_applications", "lineno": 14, "outcome": "passed", "keywords": ["test_get_supported_applications", "test_workspace_capture.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.00040458235889673233, "outcome": "passed"}, "call": {"duration": 0.00015875697135925293, "outcome": "passed"}, "teardown": {"duration": 0.00024267332628369331, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_get_application_info", "lineno": 30, "outcome": "passed", "keywords": ["test_get_application_info", "test_workspace_capture.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.00038267113268375397, "outcome": "passed"}, "call": {"duration": 0.0001457161270081997, "outcome": "passed"}, "teardown": {"duration": 0.00024595391005277634, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_capture_workspace_mock", "lineno": 53, "outcome": "passed", "keywords": ["test_capture_workspace_mock", "test_workspace_capture.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0004227082245051861, "outcome": "passed"}, "call": {"duration": 0.002274401020258665, "outcome": "passed"}, "teardown": {"duration": 0.0003066137433052063, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_restore_workspace_mock", "lineno": 113, "outcome": "passed", "keywords": ["test_restore_workspace_mock", "test_workspace_capture.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0006399177946150303, "outcome": "passed"}, "call": {"duration": 0.0025532147847115993, "outcome": "passed"}, "teardown": {"duration": 0.0003006560727953911, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_error_handling_for_nonexistent_workspace", "lineno": 167, "outcome": "passed", "keywords": ["test_error_handling_for_nonexistent_workspace", "test_workspace_capture.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.000395831186324358, "outcome": "passed"}, "call": {"duration": 0.00020268093794584274, "outcome": "passed"}, "teardown": {"duration": 0.0002450551837682724, "outcome": "passed"}}, {"nodeid": "tests/digital_artist/test_workspace_capture.py::test_list_workspace_states", "lineno": 176, "outcome": "passed", "keywords": ["test_list_workspace_states", "test_workspace_capture.py", "digital_artist", "tests", "unified", ""], "setup": {"duration": 0.0004207612946629524, "outcome": "passed"}, "call": {"duration": 0.001934998668730259, "outcome": "passed"}, "teardown": {"duration": 0.0002895090728998184, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_base_chunker", "lineno": 62, "outcome": "passed", "keywords": ["test_base_chunker", "test_chunking.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0005986201576888561, "outcome": "passed"}, "call": {"duration": 0.00023111607879400253, "outcome": "passed"}, "teardown": {"duration": 0.00013547204434871674, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_texture_chunker", "lineno": 84, "outcome": "passed", "keywords": ["test_texture_chunker", "test_chunking.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0002496703527867794, "outcome": "passed"}, "call": {"duration": 0.00015875697135925293, "outcome": "passed"}, "teardown": {"duration": 0.00012553809210658073, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_audio_chunker", "lineno": 105, "outcome": "passed", "keywords": ["test_audio_chunker", "test_chunking.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00024009589105844498, "outcome": "passed"}, "call": {"duration": 0.00016336888074874878, "outcome": "passed"}, "teardown": {"duration": 0.0001274682581424713, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_model_chunker", "lineno": 125, "outcome": "passed", "keywords": ["test_model_chunker", "test_chunking.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00023568421602249146, "outcome": "passed"}, "call": {"duration": 0.0002019200474023819, "outcome": "passed"}, "teardown": {"duration": 0.00013164523988962173, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_chunker_factory", "lineno": 145, "outcome": "passed", "keywords": ["test_chunker_factory", "test_chunking.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00010801386088132858, "outcome": "passed"}, "call": {"duration": 0.00022496702149510384, "outcome": "passed"}, "teardown": {"duration": 0.00010534701868891716, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_chunker_edge_cases", "lineno": 170, "outcome": "passed", "keywords": ["test_chunker_edge_cases", "test_chunking.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00010266201570630074, "outcome": "passed"}, "call": {"duration": 0.00018861331045627594, "outcome": "passed"}, "teardown": {"duration": 0.00010067177936434746, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_chunking.py::test_chunk_size_constraints", "lineno": 192, "outcome": "failed", "keywords": ["test_chunk_size_constraints", "test_chunking.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00010978756472468376, "outcome": "passed"}, "call": {"duration": 0.3579930583946407, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/asset_optimization/test_chunking.py", "lineno": 209, "message": "AssertionError: assert 131073 <= (128 * 1024)\n +  where 131073 = len(b'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKL...TUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFG')"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_chunking.py", "lineno": 209, "message": "AssertionError"}], "longrepr": "def test_chunk_size_constraints():\n        \"\"\"Test that chunks respect size constraints.\"\"\"\n        # Create a large repeating pattern\n        data = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" * 10000\n    \n        # Create chunkers with different min/max sizes\n        chunker1 = AssetChunker(min_chunk_size=64 * 1024, max_chunk_size=128 * 1024)\n        chunker2 = AssetChunker(min_chunk_size=32 * 1024, max_chunk_size=64 * 1024)\n    \n        # Chunk the data\n        chunks1 = chunker1.chunk_data(data)\n        chunks2 = chunker2.chunk_data(data)\n    \n        # Verify chunk sizes respect constraints\n        for chunk in chunks1:\n            assert len(chunk) >= 64 * 1024\n>           assert len(chunk) <= 128 * 1024\nE           AssertionError: assert 131073 <= (128 * 1024)\nE            +  where 131073 = len(b'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKL...TUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFG')\n\ntests/game_developer/asset_optimization/test_chunking.py:209: AssertionError"}, "teardown": {"duration": 0.0001931842416524887, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_base_compressor", "lineno": 32, "outcome": "failed", "keywords": ["test_base_compressor", "test_compressor.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0002462873235344887, "outcome": "passed"}, "call": {"duration": 0.00020331097766757011, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_compressor.py", "lineno": 38, "message": ""}, {"path": "gamevault/asset_optimization/compressor.py", "lineno": 37, "message": "in compress"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\ntest_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}\n\n    def test_base_compressor(test_data):\n        \"\"\"Test the base asset compressor.\"\"\"\n        compressor = AssetCompressor()\n    \n        # Test compression and decompression of repeating data\n>       compressed = compressor.compress(test_data[\"repeating\"])\n\ntests/game_developer/asset_optimization/test_compressor.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/compressor.py:37: in compress\n    return compress_data(data)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00018755393102765083, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_texture_compressor", "lineno": 54, "outcome": "failed", "keywords": ["test_texture_compressor", "test_compressor.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00020219897851347923, "outcome": "passed"}, "call": {"duration": 0.0001566731370985508, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_compressor.py", "lineno": 60, "message": ""}, {"path": "gamevault/asset_optimization/compressor.py", "lineno": 80, "message": "in compress"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\ntest_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}\n\n    def test_texture_compressor(test_data):\n        \"\"\"Test the texture compressor.\"\"\"\n        compressor = TextureCompressor()\n    \n        # Test compression and decompression\n>       compressed = compressor.compress(test_data[\"mixed\"])\n\ntests/game_developer/asset_optimization/test_compressor.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/compressor.py:80: in compress\n    return compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0001780749298632145, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_audio_compressor", "lineno": 69, "outcome": "failed", "keywords": ["test_audio_compressor", "test_compressor.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00019290903583168983, "outcome": "passed"}, "call": {"duration": 0.00017831986770033836, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 2"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_compressor.py", "lineno": 75, "message": ""}, {"path": "gamevault/asset_optimization/compressor.py", "lineno": 111, "message": "in compress"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 2, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 2\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\ntest_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}\n\n    def test_audio_compressor(test_data):\n        \"\"\"Test the audio compressor.\"\"\"\n        compressor = AudioCompressor()\n    \n        # Test compression and decompression\n>       compressed = compressor.compress(test_data[\"mixed\"])\n\ntests/game_developer/asset_optimization/test_compressor.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/compressor.py:111: in compress\n    return compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 2, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 2\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0001759757287800312, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_model_compressor", "lineno": 84, "outcome": "failed", "keywords": ["test_model_compressor", "test_compressor.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00028682081028819084, "outcome": "passed"}, "call": {"duration": 0.00016660010442137718, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 5"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_compressor.py", "lineno": 90, "message": ""}, {"path": "gamevault/asset_optimization/compressor.py", "lineno": 142, "message": "in compress"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 5, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 5\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\ntest_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}\n\n    def test_model_compressor(test_data):\n        \"\"\"Test the model compressor.\"\"\"\n        compressor = ModelCompressor()\n    \n        # Test compression and decompression\n>       compressed = compressor.compress(test_data[\"mixed\"])\n\ntests/game_developer/asset_optimization/test_compressor.py:90: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/compressor.py:142: in compress\n    return compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 5, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 5\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00018029287457466125, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_compressor_factory", "lineno": 99, "outcome": "passed", "keywords": ["test_compressor_factory", "test_compressor.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00011879811063408852, "outcome": "passed"}, "call": {"duration": 0.00016411812976002693, "outcome": "passed"}, "teardown": {"duration": 0.00010996824130415916, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_delta_compressor", "lineno": 124, "outcome": "failed", "keywords": ["test_delta_compressor", "test_compressor.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00017944583669304848, "outcome": "passed"}, "call": {"duration": 0.0011241231113672256, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 9"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_compressor.py", "lineno": 156, "message": ""}, {"path": "gamevault/asset_optimization/compressor.py", "lineno": 191, "message": "in compress_delta"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'BSDIFF403\\x00\\x00\\x00\\x00\\x00\\x00\\x00,\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x16\\x1f\\x00\\x00\\x00\\x00\\x00\\x00BZh91AY&SY\\xf4\\xda...\\x94\\xa6\\x9ca\\x00\\x00\\x1c\\x04\\x00?\\xe2\\xa0\\x001\\x00\\xd3M\\x03ji\\r1H\\x844J;\\x97H\\x947\\xf4XC\\xbc\\xd1w$S\\x85\\t\\tJi\\xc6\\x10'\nalgorithm = 9, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 9\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\ntest_data = {'mixed': b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHAB...DEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'}\n\n    def test_delta_compressor(test_data):\n        \"\"\"Test the delta compressor.\"\"\"\n        compressor = DeltaCompressor()\n    \n        # Create a source and target with some changes - use larger data to ensure compression savings\n        # The issue with the previous test is that the data was too small for effective delta compression\n        source_data = b\"A\" * 1000 + b\"This is the original data with some content that will remain the same.\" + b\"B\" * 1000\n        target_data = b\"A\" * 1000 + b\"This is the modified data with some content that will remain the same.\" + b\"B\" * 1000\n    \n        # Create a delta\n        delta = compressor.create_delta(source_data, target_data)\n    \n        # Due to overhead of the delta format, small changes in small files might not result in smaller delta\n        # So we'll just make sure the delta works properly without checking size\n    \n        # Apply the delta to recreate the target\n        reconstructed = compressor.apply_delta(source_data, delta)\n    \n        # Verify the reconstruction matches the target\n        assert reconstructed == target_data\n    \n        # Test with the test data\n        base = test_data[\"repeating\"]\n        modified = base[:-100] + b\"MODIFIED\" + base[-50:]  # Modify a small part\n    \n        delta = compressor.create_delta(base, modified)\n        reconstructed = compressor.apply_delta(base, delta)\n    \n        assert reconstructed == modified\n    \n        # Test delta compression\n>       compressed_delta = compressor.compress_delta(delta)\n\ntests/game_developer/asset_optimization/test_compressor.py:156: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/compressor.py:191: in compress_delta\n    return compress_data(delta_data, compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'BSDIFF403\\x00\\x00\\x00\\x00\\x00\\x00\\x00,\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x16\\x1f\\x00\\x00\\x00\\x00\\x00\\x00BZh91AY&SY\\xf4\\xda...\\x94\\xa6\\x9ca\\x00\\x00\\x1c\\x04\\x00?\\xe2\\xa0\\x001\\x00\\xd3M\\x03ji\\r1H\\x844J;\\x97H\\x947\\xf4XC\\xbc\\xd1w$S\\x85\\t\\tJi\\xc6\\x10'\nalgorithm = 9, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 9\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0001888759434223175, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_compressor.py::test_compression_levels", "lineno": 167, "outcome": "failed", "keywords": ["test_compression_levels", "test_compressor.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00012097135186195374, "outcome": "passed"}, "call": {"duration": 0.00016238028183579445, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_compressor.py", "lineno": 176, "message": ""}, {"path": "gamevault/asset_optimization/compressor.py", "lineno": 37, "message": "in compress"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\n    def test_compression_levels():\n        \"\"\"Test different compression levels.\"\"\"\n        data = b\"ABCDEFGH\" * 10000  # Highly compressible data\n    \n        # Test different compression levels\n        sizes = []\n        for level in range(1, 10, 3):  # Test levels 1, 4, 7\n            compressor = AssetCompressor()\n>           compressed = compressor.compress(data)\n\ntests/game_developer/asset_optimization/test_compressor.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/compressor.py:37: in compress\n    return compress_data(data)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCD...CDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH'\nalgorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00019017094746232033, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_add_chunk", "lineno": 33, "outcome": "passed", "keywords": ["test_chunk_hash_index_add_chunk", "test_deduplication.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0002467650920152664, "outcome": "passed"}, "call": {"duration": 0.00014765886589884758, "outcome": "passed"}, "teardown": {"duration": 0.00013179192319512367, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_remove_chunk", "lineno": 63, "outcome": "passed", "keywords": ["test_chunk_hash_index_remove_chunk", "test_deduplication.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0015852819196879864, "outcome": "passed"}, "call": {"duration": 0.0001536048948764801, "outcome": "passed"}, "teardown": {"duration": 0.00013105012476444244, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_remove_file", "lineno": 97, "outcome": "passed", "keywords": ["test_chunk_hash_index_remove_file", "test_deduplication.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00017187697812914848, "outcome": "passed"}, "call": {"duration": 0.000137335155159235, "outcome": "passed"}, "teardown": {"duration": 0.00012426311150193214, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_get_duplicate_chunks", "lineno": 126, "outcome": "passed", "keywords": ["test_chunk_hash_index_get_duplicate_chunks", "test_deduplication.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0001861797645688057, "outcome": "passed"}, "call": {"duration": 0.0001371791586279869, "outcome": "passed"}, "teardown": {"duration": 0.00012091314420104027, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_get_storage_savings", "lineno": 158, "outcome": "passed", "keywords": ["test_chunk_hash_index_get_storage_savings", "test_deduplication.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.000167015939950943, "outcome": "passed"}, "call": {"duration": 0.00013422686606645584, "outcome": "passed"}, "teardown": {"duration": 0.00011886376887559891, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_chunk_hash_index_get_file_sharing_stats", "lineno": 192, "outcome": "passed", "keywords": ["test_chunk_hash_index_get_file_sharing_stats", "test_deduplication.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00015891296789050102, "outcome": "passed"}, "call": {"duration": 0.00014593778178095818, "outcome": "passed"}, "teardown": {"duration": 0.0001216251403093338, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_deduplication.py::test_asset_deduplicator_deduplicate_file", "lineno": 217, "outcome": "passed", "keywords": ["test_asset_deduplicator_deduplicate_file", "test_deduplication.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00016173673793673515, "outcome": "passed"}, "call": {"duration": 0.0001801634207367897, "outcome": "passed"}, "teardown": {"duration": 0.0001245131716132164, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_optimize_text_file", "lineno": 65, "outcome": "failed", "keywords": ["test_optimize_text_file", "test_manager.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0008431067690253258, "outcome": "passed"}, "call": {"duration": 0.00036364002153277397, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_manager.py", "lineno": 69, "message": ""}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 81, "message": "in optimize_asset"}, {"path": "gamevault/backup_engine/storage.py", "lineno": 99, "message": "in store_file"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'This is a text file for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\noptimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974e840460>\ntest_files = {'audio': PosixPath('/tmp/tmpz8f7mp7e/sound.wav'), 'image': PosixPath('/tmp/tmpz8f7mp7e/image.png'), 'model': PosixPath('/tmp/tmpz8f7mp7e/model.fbx'), 'text': PosixPath('/tmp/tmpz8f7mp7e/text_file.txt')}\n\n    def test_optimize_text_file(optimization_manager, test_files):\n        \"\"\"Test optimizing a text file.\"\"\"\n        # Optimize the text file\n>       file_info = optimization_manager.optimize_asset(test_files[\"text\"])\n\ntests/game_developer/asset_optimization/test_manager.py:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/manager.py:81: in optimize_asset\n    file_hash, storage_path = self.storage_manager.store_file(file_path)\ngamevault/backup_engine/storage.py:99: in store_file\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'This is a text file for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00047702202573418617, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_optimize_binary_file", "lineno": 77, "outcome": "failed", "keywords": ["test_optimize_binary_file", "test_manager.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0007396847940981388, "outcome": "passed"}, "call": {"duration": 0.0012714611366391182, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_manager.py", "lineno": 86, "message": ""}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 141, "message": "in optimize_asset"}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 141, "message": "in <listcomp>"}, {"path": "gamevault/asset_optimization/compressor.py", "lineno": 80, "message": "in compress"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'\\x89PNG\\r\\n\\x1a\\n8e\\xe3\\xbd_\\xdd\\x0f?\\xf6Ih\\xb0\\xf4\\xa5\\xeb\\\\,g\\xbeVo\\xdd\\xb5m\\xb4\\xd5k\\xa9\\xe1\\t\\xa2>\\x01\\x9b\\x1dB\\...xfa\\xb1\\xa7\\x05\\x80\\x1c\\x10\\xc4W\\xa3\\xee\\xa6\\xbd\\xed\\\\\\xc4K\\x93\\xe72>\\x88\\xc7\\x10\\x86\\xfcr\\x84\\x8b3%\\x10\\xa2\\xc5\\x02+{'\nalgorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\noptimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974eace590>\ntest_files = {'audio': PosixPath('/tmp/tmpgmalfgyg/sound.wav'), 'image': PosixPath('/tmp/tmpgmalfgyg/image.png'), 'model': PosixPath('/tmp/tmpgmalfgyg/model.fbx'), 'text': PosixPath('/tmp/tmpgmalfgyg/text_file.txt')}\n\n    def test_optimize_binary_file(optimization_manager, test_files):\n        \"\"\"Test optimizing a binary file.\"\"\"\n        # Create a larger binary file to ensure it generates chunks\n        with open(test_files[\"image\"], \"wb\") as f:\n            f.write(b\"\\x89PNG\\r\\n\\x1a\\n\")  # PNG header\n            f.write(os.urandom(200000))  # Large random binary data\n    \n        # Optimize the image file\n>       file_info = optimization_manager.optimize_asset(test_files[\"image\"])\n\ntests/game_developer/asset_optimization/test_manager.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/manager.py:141: in optimize_asset\n    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]\ngamevault/asset_optimization/manager.py:141: in <listcomp>\n    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]\ngamevault/asset_optimization/compressor.py:80: in compress\n    return compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'\\x89PNG\\r\\n\\x1a\\n8e\\xe3\\xbd_\\xdd\\x0f?\\xf6Ih\\xb0\\xf4\\xa5\\xeb\\\\,g\\xbeVo\\xdd\\xb5m\\xb4\\xd5k\\xa9\\xe1\\t\\xa2>\\x01\\x9b\\x1dB\\...xfa\\xb1\\xa7\\x05\\x80\\x1c\\x10\\xc4W\\xa3\\xee\\xa6\\xbd\\xed\\\\\\xc4K\\x93\\xe72>\\x88\\xc7\\x10\\x86\\xfcr\\x84\\x8b3%\\x10\\xa2\\xc5\\x02+{'\nalgorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.000459140632301569, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_optimize_with_previous_version", "lineno": 95, "outcome": "failed", "keywords": ["test_optimize_with_previous_version", "test_manager.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0007487819530069828, "outcome": "passed"}, "call": {"duration": 0.00031583989039063454, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 5"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_manager.py", "lineno": 99, "message": ""}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 141, "message": "in optimize_asset"}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 141, "message": "in <listcomp>"}, {"path": "gamevault/asset_optimization/compressor.py", "lineno": 142, "message": "in compress"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'Kaydara FBX Binary\\x00\\x1b\\x10\\x983\\x85\\x1a[%sOP\\xcc\\xd5\\x15Df\\xd4\\xbb\\xd9\\xa9$\\xf9\\x87U\\x98M\\x1a\\x13\\xa1\\x9a\\xf0t\\x...3\\xc8\\xa3\\xd2 b=\\xf8\\xe2\\x03l\\x90g\\x82Zw\\x0c\\xd5T\\xf6Mi\\'\\x1b\\xc0\\xeea\\x08\\x9d\\xec\\x93\\x04&{\\xc2\\xac\\x17M\\xf7\\x8b\\xbez'\nalgorithm = 5, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 5\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\noptimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974eb529e0>\ntest_files = {'audio': PosixPath('/tmp/tmpwl99ty34/sound.wav'), 'image': PosixPath('/tmp/tmpwl99ty34/image.png'), 'model': PosixPath('/tmp/tmpwl99ty34/model.fbx'), 'text': PosixPath('/tmp/tmpwl99ty34/text_file.txt')}\n\n    def test_optimize_with_previous_version(optimization_manager, test_files):\n        \"\"\"Test optimizing a file with a previous version available.\"\"\"\n        # First optimize without a previous version\n>       initial_info = optimization_manager.optimize_asset(test_files[\"model\"])\n\ntests/game_developer/asset_optimization/test_manager.py:99: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/manager.py:141: in optimize_asset\n    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]\ngamevault/asset_optimization/manager.py:141: in <listcomp>\n    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]\ngamevault/asset_optimization/compressor.py:142: in compress\n    return compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'Kaydara FBX Binary\\x00\\x1b\\x10\\x983\\x85\\x1a[%sOP\\xcc\\xd5\\x15Df\\xd4\\xbb\\xd9\\xa9$\\xf9\\x87U\\x98M\\x1a\\x13\\xa1\\x9a\\xf0t\\x...3\\xc8\\xa3\\xd2 b=\\xf8\\xe2\\x03l\\x90g\\x82Zw\\x0c\\xd5T\\xf6Mi\\'\\x1b\\xc0\\xeea\\x08\\x9d\\xec\\x93\\x04&{\\xc2\\xac\\x17M\\xf7\\x8b\\xbez'\nalgorithm = 5, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 5\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0004407968372106552, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_restore_asset", "lineno": 121, "outcome": "failed", "keywords": ["test_restore_asset", "test_manager.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0007821382023394108, "outcome": "passed"}, "call": {"duration": 0.0003472641110420227, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_manager.py", "lineno": 125, "message": ""}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 81, "message": "in optimize_asset"}, {"path": "gamevault/backup_engine/storage.py", "lineno": 99, "message": "in store_file"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'This is a text file for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\noptimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974ed12110>\ntest_files = {'audio': PosixPath('/tmp/tmpn7spfwd6/sound.wav'), 'image': PosixPath('/tmp/tmpn7spfwd6/image.png'), 'model': PosixPath('/tmp/tmpn7spfwd6/model.fbx'), 'text': PosixPath('/tmp/tmpn7spfwd6/text_file.txt')}\n\n    def test_restore_asset(optimization_manager, test_files):\n        \"\"\"Test restoring an optimized asset.\"\"\"\n        # Optimize a text file which is simpler to restore\n>       file_info = optimization_manager.optimize_asset(test_files[\"text\"])\n\ntests/game_developer/asset_optimization/test_manager.py:125: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/manager.py:81: in optimize_asset\n    file_hash, storage_path = self.storage_manager.store_file(file_path)\ngamevault/backup_engine/storage.py:99: in store_file\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'This is a text file for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0005774460732936859, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_get_optimization_stats", "lineno": 148, "outcome": "failed", "keywords": ["test_get_optimization_stats", "test_manager.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0007535447366535664, "outcome": "passed"}, "call": {"duration": 0.00040460191667079926, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_manager.py", "lineno": 155, "message": ""}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 81, "message": "in optimize_asset"}, {"path": "gamevault/backup_engine/storage.py", "lineno": 99, "message": "in store_file"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'This is a text file for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\noptimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974e86e110>\ntest_files = {'audio': PosixPath('/tmp/tmptjgwoonl/sound.wav'), 'image': PosixPath('/tmp/tmptjgwoonl/image.png'), 'model': PosixPath('/tmp/tmptjgwoonl/model.fbx'), 'text': PosixPath('/tmp/tmptjgwoonl/text_file.txt')}\n\n    def test_get_optimization_stats(optimization_manager, test_files):\n        \"\"\"Test getting optimization statistics.\"\"\"\n        # Initially should have no storage used\n        stats_before = optimization_manager.get_optimization_stats()\n    \n        # Optimize some files\n>       optimization_manager.optimize_asset(test_files[\"text\"])\n\ntests/game_developer/asset_optimization/test_manager.py:155: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/manager.py:81: in optimize_asset\n    file_hash, storage_path = self.storage_manager.store_file(file_path)\ngamevault/backup_engine/storage.py:99: in store_file\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'This is a text file for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0004688962362706661, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_get_shared_asset_analysis", "lineno": 164, "outcome": "failed", "keywords": ["test_get_shared_asset_analysis", "test_manager.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0007457491010427475, "outcome": "passed"}, "call": {"duration": 0.00030848290771245956, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 5"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_manager.py", "lineno": 168, "message": ""}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 141, "message": "in optimize_asset"}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 141, "message": "in <listcomp>"}, {"path": "gamevault/asset_optimization/compressor.py", "lineno": 142, "message": "in compress"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'Kaydara FBX Binary\\x00\\x01\\xd0I\\x86\\x90\\xcfz8BZ\\x1e\\t0\\x8a\\x89\\xf0\\x05{\\x1b\\xf2\\'g\\x80\\xd7\\x9c#i\\xcf\\xd6QU\\x9e{\\xb9{...|w]%\\xa5\\x1b\\x1bC\\xab\\xb0?\\xfb\\\\\\x1d\\xb3\\x8b\\xdfO\\xcd,}\\xd9\\x16\\xecd\\xb5\\x90\\xba\\x00Gr\\x12\\x08\\x90!HgD[\\x03H\\n\\x8b\\x83'\nalgorithm = 5, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 5\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\noptimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974c291360>\ntest_files = {'audio': PosixPath('/tmp/tmp4nbw08u0/sound.wav'), 'image': PosixPath('/tmp/tmp4nbw08u0/image.png'), 'model': PosixPath('/tmp/tmp4nbw08u0/model.fbx'), 'text': PosixPath('/tmp/tmp4nbw08u0/text_file.txt')}\n\n    def test_get_shared_asset_analysis(optimization_manager, test_files):\n        \"\"\"Test analyzing shared asset content.\"\"\"\n        # Optimize some files\n>       optimization_manager.optimize_asset(test_files[\"model\"])\n\ntests/game_developer/asset_optimization/test_manager.py:168: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/asset_optimization/manager.py:141: in optimize_asset\n    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]\ngamevault/asset_optimization/manager.py:141: in <listcomp>\n    compressed_chunks = [compressor.compress(chunk) for chunk in chunks]\ngamevault/asset_optimization/compressor.py:142: in compress\n    return compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'Kaydara FBX Binary\\x00\\x01\\xd0I\\x86\\x90\\xcfz8BZ\\x1e\\t0\\x8a\\x89\\xf0\\x05{\\x1b\\xf2\\'g\\x80\\xd7\\x9c#i\\xcf\\xd6QU\\x9e{\\xb9{...|w]%\\xa5\\x1b\\x1bC\\xab\\xb0?\\xfb\\\\\\x1d\\xb3\\x8b\\xdfO\\xcd,}\\xd9\\x16\\xecd\\xb5\\x90\\xba\\x00Gr\\x12\\x08\\x90!HgD[\\x03H\\n\\x8b\\x83'\nalgorithm = 5, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 5\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00041972892358899117, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_delta_compression", "lineno": 177, "outcome": "failed", "keywords": ["test_delta_compression", "test_manager.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0007478957995772362, "outcome": "passed"}, "call": {"duration": 0.00017140991985797882, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/asset_optimization/test_manager.py", "lineno": 181, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_manager.py", "lineno": 181, "message": "TypeError"}], "longrepr": "optimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974e8413c0>\ntest_files = {'audio': PosixPath('/tmp/tmpenxn7uc7/sound.wav'), 'image': PosixPath('/tmp/tmpenxn7uc7/image.png'), 'model': PosixPath('/tmp/tmpenxn7uc7/model.fbx'), 'text': PosixPath('/tmp/tmpenxn7uc7/text_file.txt')}\n\n    def test_delta_compression(optimization_manager, test_files):\n        \"\"\"Test delta compression between versions.\"\"\"\n        # Create a previous version file info\n>       prev_version = FileInfo(\n            path=\"test.bin\",\n            size=100,\n            hash=\"prev_hash\",\n            modified_time=1000.0,\n            is_binary=True,\n            chunks=[\"chunk1\", \"chunk2\"]\n        )\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/asset_optimization/test_manager.py:181: TypeError"}, "teardown": {"duration": 0.00042219413444399834, "outcome": "passed"}}, {"nodeid": "tests/game_developer/asset_optimization/test_manager.py::test_get_base_version", "lineno": 264, "outcome": "failed", "keywords": ["test_get_base_version", "test_manager.py", "asset_optimization", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0004055728204548359, "outcome": "passed"}, "call": {"duration": 0.001190647017210722, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/gamevault/asset_optimization/manager.py", "lineno": 288, "message": "ValueError: Failed to retrieve base version test_base_version_hash: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/asset_optimization/test_manager.py", "lineno": 286, "message": ""}, {"path": "gamevault/asset_optimization/manager.py", "lineno": 288, "message": "ValueError"}], "longrepr": "self = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974c290b50>\nbase_version_hash = 'test_base_version_hash'\n\n    def _get_base_version(self, base_version_hash: str) -> FileInfo:\n        \"\"\"\n        Get the base version for a delta-compressed file.\n    \n        Retrieves the FileInfo of a previous version based on its hash.\n    \n        Args:\n            base_version_hash: Hash of the base version\n    \n        Returns:\n            FileInfo: Information about the base version\n    \n        Raises:\n            ValueError: If the base version can't be found\n        \"\"\"\n        # Search for the file in the storage system by its hash\n        try:\n            # Check if the file exists in storage\n            file_path = self.storage_manager.get_file_path_by_hash(base_version_hash)\n            if file_path:\n                # Create basic FileInfo from the stored file\n                file_size = os.path.getsize(file_path)\n                chunks = self.storage_manager.get_chunks_for_file(base_version_hash)\n    \n>               return FileInfo(\n                    path=os.path.basename(file_path),\n                    size=file_size,\n                    hash=base_version_hash,\n                    modified_time=os.path.getmtime(file_path),\n                    is_binary=True,\n                    chunks=chunks or []\n                )\nE               TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ngamevault/asset_optimization/manager.py:264: TypeError\n\nDuring handling of the above exception, another exception occurred:\n\noptimization_manager = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974c290b50>\n\n    def test_get_base_version(optimization_manager):\n        \"\"\"Test retrieving a base version using its hash.\"\"\"\n        # Setup mock for the storage manager methods\n        test_hash = \"test_base_version_hash\"\n        test_path = Path(\"/test/path/file.bin\")\n        test_size = 1024\n        test_mtime = 1600000000.0\n        test_chunks = [\"chunk1\", \"chunk2\", \"chunk3\"]\n    \n        # Test case 1: File exists in storage\n        with patch.object(optimization_manager.storage_manager, \"get_file_path_by_hash\") as mock_get_path:\n            with patch.object(optimization_manager.storage_manager, \"get_chunks_for_file\") as mock_get_chunks:\n                with patch(\"os.path.getsize\") as mock_getsize:\n                    with patch(\"os.path.getmtime\") as mock_getmtime:\n                        # Set up the mocks\n                        mock_get_path.return_value = test_path\n                        mock_get_chunks.return_value = test_chunks\n                        mock_getsize.return_value = test_size\n                        mock_getmtime.return_value = test_mtime\n    \n                        # Call the method\n>                       file_info = optimization_manager._get_base_version(test_hash)\n\ntests/game_developer/asset_optimization/test_manager.py:286: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.asset_optimization.manager.AssetOptimizationManager object at 0x7f974c290b50>\nbase_version_hash = 'test_base_version_hash'\n\n    def _get_base_version(self, base_version_hash: str) -> FileInfo:\n        \"\"\"\n        Get the base version for a delta-compressed file.\n    \n        Retrieves the FileInfo of a previous version based on its hash.\n    \n        Args:\n            base_version_hash: Hash of the base version\n    \n        Returns:\n            FileInfo: Information about the base version\n    \n        Raises:\n            ValueError: If the base version can't be found\n        \"\"\"\n        # Search for the file in the storage system by its hash\n        try:\n            # Check if the file exists in storage\n            file_path = self.storage_manager.get_file_path_by_hash(base_version_hash)\n            if file_path:\n                # Create basic FileInfo from the stored file\n                file_size = os.path.getsize(file_path)\n                chunks = self.storage_manager.get_chunks_for_file(base_version_hash)\n    \n                return FileInfo(\n                    path=os.path.basename(file_path),\n                    size=file_size,\n                    hash=base_version_hash,\n                    modified_time=os.path.getmtime(file_path),\n                    is_binary=True,\n                    chunks=chunks or []\n                )\n    \n            # If no direct file is found, try looking for chunks\n            chunks = self.storage_manager.get_chunks_for_file(base_version_hash)\n            if chunks:\n                # Return FileInfo with just the chunks\n                return FileInfo(\n                    path=\"unknown\",  # Path is not critical for reconstruction\n                    size=0,  # Size will be determined after reconstruction\n                    hash=base_version_hash,\n                    modified_time=0,  # Not critical for reconstruction\n                    is_binary=True,\n                    chunks=chunks\n                )\n    \n            raise ValueError(f\"Base version {base_version_hash} not found\")\n        except Exception as e:\n>           raise ValueError(f\"Failed to retrieve base version {base_version_hash}: {str(e)}\")\nE           ValueError: Failed to retrieve base version test_base_version_hash: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ngamevault/asset_optimization/manager.py:288: ValueError"}, "teardown": {"duration": 0.0003358740359544754, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_fixed_size_chunker", "lineno": 32, "outcome": "passed", "keywords": ["test_fixed_size_chunker", "test_chunking.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.09169802675023675, "outcome": "passed"}, "call": {"duration": 0.0018460559658706188, "outcome": "passed"}, "teardown": {"duration": 0.0001431661657989025, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_rolling_hash_chunker", "lineno": 62, "outcome": "passed", "keywords": ["test_rolling_hash_chunker", "test_chunking.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.09104188298806548, "outcome": "passed"}, "call": {"duration": 0.7991669080220163, "outcome": "passed"}, "teardown": {"duration": 0.00020903069525957108, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_game_asset_chunker", "lineno": 98, "outcome": "passed", "keywords": ["test_game_asset_chunker", "test_chunking.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00013259192928671837, "outcome": "passed"}, "call": {"duration": 0.22336224792525172, "outcome": "passed"}, "teardown": {"duration": 0.0001513841561973095, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_chunker_edge_cases", "lineno": 132, "outcome": "passed", "keywords": ["test_chunker_edge_cases", "test_chunking.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00012623798102140427, "outcome": "passed"}, "call": {"duration": 0.00020134123042225838, "outcome": "passed"}, "teardown": {"duration": 0.00012782495468854904, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_chunking.py::test_chunker_consistency", "lineno": 153, "outcome": "passed", "keywords": ["test_chunker_consistency", "test_chunking.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00011622626334428787, "outcome": "passed"}, "call": {"duration": 0.71173772867769, "outcome": "passed"}, "teardown": {"duration": 0.00015494972467422485, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_create_backup", "lineno": 55, "outcome": "failed", "keywords": ["test_create_backup", "test_engine.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0013502510264515877, "outcome": "passed"}, "call": {"duration": 0.0015602149069309235, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/gamevault/backup_engine/engine.py", "lineno": 285, "message": "common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_engine.py", "lineno": 59, "message": ""}, {"path": "gamevault/backup_engine/engine.py", "lineno": 285, "message": "BackupSystemError"}], "longrepr": "self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>\nsource_path = PosixPath('/tmp/tmp8gi_09nv/test_project')\ntags = {'initial', 'test', 'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n>           current_files = self._scan_source_files(source_path)\n\ncommon/core/backup_engine.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncommon/core/backup_engine.py:390: in _scan_source_files\n    for file_path in scan_directory(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndirectory = PosixPath('/tmp/tmp8gi_09nv/test_project')\nignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]\nfollow_symlinks = False, include_hidden = False\n\n    def scan_directory(\n        directory: Union[str, Path],\n        ignore_patterns: Optional[List[str]] = None,\n        follow_symlinks: bool = False,\n        include_hidden: bool = False\n    ) -> Iterator[Path]:\n        \"\"\"\n        Recursively scan directory for files.\n    \n        Args:\n            directory: Directory to scan\n            ignore_patterns: List of glob patterns to ignore\n            follow_symlinks: Whether to follow symbolic links\n            include_hidden: Whether to include hidden files/directories\n    \n        Yields:\n            Path objects for each file found\n        \"\"\"\n        directory = Path(directory)\n        if not directory.exists() or not directory.is_dir():\n            return\n    \n        ignore_patterns = ignore_patterns or []\n    \n        try:\n            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):\n                root_path = Path(root)\n    \n                # Filter hidden directories if not including them\n                if not include_hidden:\n                    dirs[:] = [d for d in dirs if not d.startswith('.')]\n    \n                # Apply ignore patterns to directories\n                for pattern in ignore_patterns:\n                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]\n    \n                for file in files:\n                    # Skip hidden files if not including them\n                    if not include_hidden and file.startswith('.'):\n                        continue\n    \n                    file_path = root_path / file\n    \n                    # Apply ignore patterns to files\n                    should_ignore = False\n                    for pattern in ignore_patterns:\n>                       if file_path.match(pattern) or file_path.name.match(pattern):\nE                       AttributeError: 'str' object has no attribute 'match'\n\ncommon/core/file_utils.py:62: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>\nname = 'test backup'\nversion_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = 'Test backup', is_milestone = False, tags = ['test', 'initial']\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n>           snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n\ngamevault/backup_engine/engine.py:266: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>\nsource_path = PosixPath('/tmp/tmp8gi_09nv/test_project')\ntags = {'initial', 'test', 'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n            current_files = self._scan_source_files(source_path)\n    \n            # Calculate changes\n            changes = self._calculate_changes(parent_files, current_files)\n    \n            # Store chunks for new/modified files\n            stored_files = self._store_file_chunks(current_files, changes)\n    \n            # Create snapshot info\n            snapshot = SnapshotInfo(\n                id=snapshot_id,\n                timestamp=datetime.now(),\n                source_path=source_path,\n                parent_id=parent_id,\n                files=list(stored_files.values()),\n                changes=changes,\n                tags=tags or set()\n            )\n    \n            # Store snapshot metadata\n            self._store_snapshot_metadata(snapshot)\n    \n            return snapshot\n    \n        except Exception as e:\n>           raise SnapshotError(f\"Failed to create snapshot: {e}\")\nE           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'\n\ncommon/core/backup_engine.py:135: SnapshotError\n\nDuring handling of the above exception, another exception occurred:\n\nbackup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>\nproject_dir = PosixPath('/tmp/tmp8gi_09nv/test_project')\n\n    def test_create_backup(backup_engine, project_dir):\n        \"\"\"Test creating a backup of a project.\"\"\"\n        # Create a backup\n>       version = backup_engine.create_backup(\n            name=\"test backup\",\n            version_type=GameVersionType.DEVELOPMENT,\n            description=\"Test backup\",\n            is_milestone=False,\n            tags=[\"test\", \"initial\"]\n        )\n\ntests/game_developer/backup_engine/test_engine.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e812680>\nname = 'test backup'\nversion_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = 'Test backup', is_milestone = False, tags = ['test', 'initial']\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n            snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n    \n            # Convert snapshot to ProjectVersion for game-specific interface\n            project_version = ProjectVersion.from_common_snapshot_info(\n                snapshot=snapshot,\n                name=name,\n                version_type=version_type,\n                is_milestone=is_milestone\n            )\n    \n            # Store game-specific metadata in the version tracker\n            self.version_tracker.store_version_metadata(project_version)\n    \n            return project_version\n    \n        except Exception as e:\n>           raise BackupSystemError(f\"Failed to create backup: {e}\")\nE           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'\n\ngamevault/backup_engine/engine.py:285: BackupSystemError"}, "teardown": {"duration": 0.0006110030226409435, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_incremental_backup", "lineno": 81, "outcome": "failed", "keywords": ["test_incremental_backup", "test_engine.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.001054374035447836, "outcome": "passed"}, "call": {"duration": 0.0005478388629853725, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/gamevault/backup_engine/engine.py", "lineno": 285, "message": "common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_engine.py", "lineno": 85, "message": ""}, {"path": "gamevault/backup_engine/engine.py", "lineno": 285, "message": "BackupSystemError"}], "longrepr": "self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>\nsource_path = PosixPath('/tmp/tmpmvwbfp1o/test_project')\ntags = {'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n>           current_files = self._scan_source_files(source_path)\n\ncommon/core/backup_engine.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncommon/core/backup_engine.py:390: in _scan_source_files\n    for file_path in scan_directory(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndirectory = PosixPath('/tmp/tmpmvwbfp1o/test_project')\nignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]\nfollow_symlinks = False, include_hidden = False\n\n    def scan_directory(\n        directory: Union[str, Path],\n        ignore_patterns: Optional[List[str]] = None,\n        follow_symlinks: bool = False,\n        include_hidden: bool = False\n    ) -> Iterator[Path]:\n        \"\"\"\n        Recursively scan directory for files.\n    \n        Args:\n            directory: Directory to scan\n            ignore_patterns: List of glob patterns to ignore\n            follow_symlinks: Whether to follow symbolic links\n            include_hidden: Whether to include hidden files/directories\n    \n        Yields:\n            Path objects for each file found\n        \"\"\"\n        directory = Path(directory)\n        if not directory.exists() or not directory.is_dir():\n            return\n    \n        ignore_patterns = ignore_patterns or []\n    \n        try:\n            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):\n                root_path = Path(root)\n    \n                # Filter hidden directories if not including them\n                if not include_hidden:\n                    dirs[:] = [d for d in dirs if not d.startswith('.')]\n    \n                # Apply ignore patterns to directories\n                for pattern in ignore_patterns:\n                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]\n    \n                for file in files:\n                    # Skip hidden files if not including them\n                    if not include_hidden and file.startswith('.'):\n                        continue\n    \n                    file_path = root_path / file\n    \n                    # Apply ignore patterns to files\n                    should_ignore = False\n                    for pattern in ignore_patterns:\n>                       if file_path.match(pattern) or file_path.name.match(pattern):\nE                       AttributeError: 'str' object has no attribute 'match'\n\ncommon/core/file_utils.py:62: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>\nname = 'initial', version_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = None, is_milestone = False, tags = None\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n>           snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n\ngamevault/backup_engine/engine.py:266: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>\nsource_path = PosixPath('/tmp/tmpmvwbfp1o/test_project')\ntags = {'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n            current_files = self._scan_source_files(source_path)\n    \n            # Calculate changes\n            changes = self._calculate_changes(parent_files, current_files)\n    \n            # Store chunks for new/modified files\n            stored_files = self._store_file_chunks(current_files, changes)\n    \n            # Create snapshot info\n            snapshot = SnapshotInfo(\n                id=snapshot_id,\n                timestamp=datetime.now(),\n                source_path=source_path,\n                parent_id=parent_id,\n                files=list(stored_files.values()),\n                changes=changes,\n                tags=tags or set()\n            )\n    \n            # Store snapshot metadata\n            self._store_snapshot_metadata(snapshot)\n    \n            return snapshot\n    \n        except Exception as e:\n>           raise SnapshotError(f\"Failed to create snapshot: {e}\")\nE           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'\n\ncommon/core/backup_engine.py:135: SnapshotError\n\nDuring handling of the above exception, another exception occurred:\n\nbackup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>\nproject_dir = PosixPath('/tmp/tmpmvwbfp1o/test_project')\n\n    def test_incremental_backup(backup_engine, project_dir):\n        \"\"\"Test creating an incremental backup after changes.\"\"\"\n        # Create an initial backup\n>       initial_version = backup_engine.create_backup(name=\"initial\")\n\ntests/game_developer/backup_engine/test_engine.py:85: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2cecb0>\nname = 'initial', version_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = None, is_milestone = False, tags = None\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n            snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n    \n            # Convert snapshot to ProjectVersion for game-specific interface\n            project_version = ProjectVersion.from_common_snapshot_info(\n                snapshot=snapshot,\n                name=name,\n                version_type=version_type,\n                is_milestone=is_milestone\n            )\n    \n            # Store game-specific metadata in the version tracker\n            self.version_tracker.store_version_metadata(project_version)\n    \n            return project_version\n    \n        except Exception as e:\n>           raise BackupSystemError(f\"Failed to create backup: {e}\")\nE           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'\n\ngamevault/backup_engine/engine.py:285: BackupSystemError"}, "teardown": {"duration": 0.0005812663584947586, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_restore_version", "lineno": 119, "outcome": "failed", "keywords": ["test_restore_version", "test_engine.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.001039315015077591, "outcome": "passed"}, "call": {"duration": 0.0005259527824819088, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/gamevault/backup_engine/engine.py", "lineno": 285, "message": "common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_engine.py", "lineno": 123, "message": ""}, {"path": "gamevault/backup_engine/engine.py", "lineno": 285, "message": "BackupSystemError"}], "longrepr": "self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>\nsource_path = PosixPath('/tmp/tmp4v0ithlx/test_project')\ntags = {'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n>           current_files = self._scan_source_files(source_path)\n\ncommon/core/backup_engine.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncommon/core/backup_engine.py:390: in _scan_source_files\n    for file_path in scan_directory(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndirectory = PosixPath('/tmp/tmp4v0ithlx/test_project')\nignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]\nfollow_symlinks = False, include_hidden = False\n\n    def scan_directory(\n        directory: Union[str, Path],\n        ignore_patterns: Optional[List[str]] = None,\n        follow_symlinks: bool = False,\n        include_hidden: bool = False\n    ) -> Iterator[Path]:\n        \"\"\"\n        Recursively scan directory for files.\n    \n        Args:\n            directory: Directory to scan\n            ignore_patterns: List of glob patterns to ignore\n            follow_symlinks: Whether to follow symbolic links\n            include_hidden: Whether to include hidden files/directories\n    \n        Yields:\n            Path objects for each file found\n        \"\"\"\n        directory = Path(directory)\n        if not directory.exists() or not directory.is_dir():\n            return\n    \n        ignore_patterns = ignore_patterns or []\n    \n        try:\n            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):\n                root_path = Path(root)\n    \n                # Filter hidden directories if not including them\n                if not include_hidden:\n                    dirs[:] = [d for d in dirs if not d.startswith('.')]\n    \n                # Apply ignore patterns to directories\n                for pattern in ignore_patterns:\n                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]\n    \n                for file in files:\n                    # Skip hidden files if not including them\n                    if not include_hidden and file.startswith('.'):\n                        continue\n    \n                    file_path = root_path / file\n    \n                    # Apply ignore patterns to files\n                    should_ignore = False\n                    for pattern in ignore_patterns:\n>                       if file_path.match(pattern) or file_path.name.match(pattern):\nE                       AttributeError: 'str' object has no attribute 'match'\n\ncommon/core/file_utils.py:62: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>\nname = 'test', version_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = None, is_milestone = False, tags = None\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n>           snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n\ngamevault/backup_engine/engine.py:266: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>\nsource_path = PosixPath('/tmp/tmp4v0ithlx/test_project')\ntags = {'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n            current_files = self._scan_source_files(source_path)\n    \n            # Calculate changes\n            changes = self._calculate_changes(parent_files, current_files)\n    \n            # Store chunks for new/modified files\n            stored_files = self._store_file_chunks(current_files, changes)\n    \n            # Create snapshot info\n            snapshot = SnapshotInfo(\n                id=snapshot_id,\n                timestamp=datetime.now(),\n                source_path=source_path,\n                parent_id=parent_id,\n                files=list(stored_files.values()),\n                changes=changes,\n                tags=tags or set()\n            )\n    \n            # Store snapshot metadata\n            self._store_snapshot_metadata(snapshot)\n    \n            return snapshot\n    \n        except Exception as e:\n>           raise SnapshotError(f\"Failed to create snapshot: {e}\")\nE           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'\n\ncommon/core/backup_engine.py:135: SnapshotError\n\nDuring handling of the above exception, another exception occurred:\n\nbackup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>\nproject_dir = PosixPath('/tmp/tmp4v0ithlx/test_project')\n\n    def test_restore_version(backup_engine, project_dir):\n        \"\"\"Test restoring a backed up version.\"\"\"\n        # Create a backup\n>       version = backup_engine.create_backup(name=\"test\")\n\ntests/game_developer/backup_engine/test_engine.py:123: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e7f9570>\nname = 'test', version_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = None, is_milestone = False, tags = None\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n            snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n    \n            # Convert snapshot to ProjectVersion for game-specific interface\n            project_version = ProjectVersion.from_common_snapshot_info(\n                snapshot=snapshot,\n                name=name,\n                version_type=version_type,\n                is_milestone=is_milestone\n            )\n    \n            # Store game-specific metadata in the version tracker\n            self.version_tracker.store_version_metadata(project_version)\n    \n            return project_version\n    \n        except Exception as e:\n>           raise BackupSystemError(f\"Failed to create backup: {e}\")\nE           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'\n\ngamevault/backup_engine/engine.py:285: BackupSystemError"}, "teardown": {"duration": 0.0006349659524857998, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_restore_with_exclusions", "lineno": 151, "outcome": "failed", "keywords": ["test_restore_with_exclusions", "test_engine.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0010038632899522781, "outcome": "passed"}, "call": {"duration": 0.0005157310515642166, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/gamevault/backup_engine/engine.py", "lineno": 285, "message": "common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_engine.py", "lineno": 155, "message": ""}, {"path": "gamevault/backup_engine/engine.py", "lineno": 285, "message": "BackupSystemError"}], "longrepr": "self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>\nsource_path = PosixPath('/tmp/tmpgjd0ogls/test_project')\ntags = {'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n>           current_files = self._scan_source_files(source_path)\n\ncommon/core/backup_engine.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncommon/core/backup_engine.py:390: in _scan_source_files\n    for file_path in scan_directory(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndirectory = PosixPath('/tmp/tmpgjd0ogls/test_project')\nignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]\nfollow_symlinks = False, include_hidden = False\n\n    def scan_directory(\n        directory: Union[str, Path],\n        ignore_patterns: Optional[List[str]] = None,\n        follow_symlinks: bool = False,\n        include_hidden: bool = False\n    ) -> Iterator[Path]:\n        \"\"\"\n        Recursively scan directory for files.\n    \n        Args:\n            directory: Directory to scan\n            ignore_patterns: List of glob patterns to ignore\n            follow_symlinks: Whether to follow symbolic links\n            include_hidden: Whether to include hidden files/directories\n    \n        Yields:\n            Path objects for each file found\n        \"\"\"\n        directory = Path(directory)\n        if not directory.exists() or not directory.is_dir():\n            return\n    \n        ignore_patterns = ignore_patterns or []\n    \n        try:\n            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):\n                root_path = Path(root)\n    \n                # Filter hidden directories if not including them\n                if not include_hidden:\n                    dirs[:] = [d for d in dirs if not d.startswith('.')]\n    \n                # Apply ignore patterns to directories\n                for pattern in ignore_patterns:\n                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]\n    \n                for file in files:\n                    # Skip hidden files if not including them\n                    if not include_hidden and file.startswith('.'):\n                        continue\n    \n                    file_path = root_path / file\n    \n                    # Apply ignore patterns to files\n                    should_ignore = False\n                    for pattern in ignore_patterns:\n>                       if file_path.match(pattern) or file_path.name.match(pattern):\nE                       AttributeError: 'str' object has no attribute 'match'\n\ncommon/core/file_utils.py:62: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>\nname = 'test', version_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = None, is_milestone = False, tags = None\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n>           snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n\ngamevault/backup_engine/engine.py:266: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>\nsource_path = PosixPath('/tmp/tmpgjd0ogls/test_project')\ntags = {'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n            current_files = self._scan_source_files(source_path)\n    \n            # Calculate changes\n            changes = self._calculate_changes(parent_files, current_files)\n    \n            # Store chunks for new/modified files\n            stored_files = self._store_file_chunks(current_files, changes)\n    \n            # Create snapshot info\n            snapshot = SnapshotInfo(\n                id=snapshot_id,\n                timestamp=datetime.now(),\n                source_path=source_path,\n                parent_id=parent_id,\n                files=list(stored_files.values()),\n                changes=changes,\n                tags=tags or set()\n            )\n    \n            # Store snapshot metadata\n            self._store_snapshot_metadata(snapshot)\n    \n            return snapshot\n    \n        except Exception as e:\n>           raise SnapshotError(f\"Failed to create snapshot: {e}\")\nE           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'\n\ncommon/core/backup_engine.py:135: SnapshotError\n\nDuring handling of the above exception, another exception occurred:\n\nbackup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>\nproject_dir = PosixPath('/tmp/tmpgjd0ogls/test_project')\n\n    def test_restore_with_exclusions(backup_engine, project_dir):\n        \"\"\"Test restoring a version with exclusions.\"\"\"\n        # Create a backup\n>       version = backup_engine.create_backup(name=\"test\")\n\ntests/game_developer/backup_engine/test_engine.py:155: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e86c2e0>\nname = 'test', version_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = None, is_milestone = False, tags = None\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n            snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n    \n            # Convert snapshot to ProjectVersion for game-specific interface\n            project_version = ProjectVersion.from_common_snapshot_info(\n                snapshot=snapshot,\n                name=name,\n                version_type=version_type,\n                is_milestone=is_milestone\n            )\n    \n            # Store game-specific metadata in the version tracker\n            self.version_tracker.store_version_metadata(project_version)\n    \n            return project_version\n    \n        except Exception as e:\n>           raise BackupSystemError(f\"Failed to create backup: {e}\")\nE           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'\n\ngamevault/backup_engine/engine.py:285: BackupSystemError"}, "teardown": {"duration": 0.0006779339164495468, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_get_version_diff", "lineno": 174, "outcome": "failed", "keywords": ["test_get_version_diff", "test_engine.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0010978090576827526, "outcome": "passed"}, "call": {"duration": 0.0005539939738810062, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/gamevault/backup_engine/engine.py", "lineno": 285, "message": "common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_engine.py", "lineno": 178, "message": ""}, {"path": "gamevault/backup_engine/engine.py", "lineno": 285, "message": "BackupSystemError"}], "longrepr": "self = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>\nsource_path = PosixPath('/tmp/tmp4har2wl4/test_project')\ntags = {'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n>           current_files = self._scan_source_files(source_path)\n\ncommon/core/backup_engine.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncommon/core/backup_engine.py:390: in _scan_source_files\n    for file_path in scan_directory(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndirectory = PosixPath('/tmp/tmp4har2wl4/test_project')\nignore_patterns = ['*.tmp', '*.temp', '*.log', '*.bak', '.git/*', '.svn/*', ...]\nfollow_symlinks = False, include_hidden = False\n\n    def scan_directory(\n        directory: Union[str, Path],\n        ignore_patterns: Optional[List[str]] = None,\n        follow_symlinks: bool = False,\n        include_hidden: bool = False\n    ) -> Iterator[Path]:\n        \"\"\"\n        Recursively scan directory for files.\n    \n        Args:\n            directory: Directory to scan\n            ignore_patterns: List of glob patterns to ignore\n            follow_symlinks: Whether to follow symbolic links\n            include_hidden: Whether to include hidden files/directories\n    \n        Yields:\n            Path objects for each file found\n        \"\"\"\n        directory = Path(directory)\n        if not directory.exists() or not directory.is_dir():\n            return\n    \n        ignore_patterns = ignore_patterns or []\n    \n        try:\n            for root, dirs, files in os.walk(directory, followlinks=follow_symlinks):\n                root_path = Path(root)\n    \n                # Filter hidden directories if not including them\n                if not include_hidden:\n                    dirs[:] = [d for d in dirs if not d.startswith('.')]\n    \n                # Apply ignore patterns to directories\n                for pattern in ignore_patterns:\n                    dirs[:] = [d for d in dirs if not Path(d).match(pattern)]\n    \n                for file in files:\n                    # Skip hidden files if not including them\n                    if not include_hidden and file.startswith('.'):\n                        continue\n    \n                    file_path = root_path / file\n    \n                    # Apply ignore patterns to files\n                    should_ignore = False\n                    for pattern in ignore_patterns:\n>                       if file_path.match(pattern) or file_path.name.match(pattern):\nE                       AttributeError: 'str' object has no attribute 'match'\n\ncommon/core/file_utils.py:62: AttributeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>\nname = 'initial', version_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = None, is_milestone = False, tags = None\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n>           snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n\ngamevault/backup_engine/engine.py:266: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>\nsource_path = PosixPath('/tmp/tmp4har2wl4/test_project')\ntags = {'version_type:development'}\n\n    def create_snapshot(self, source_path: Path, tags: Optional[Set[str]] = None) -> SnapshotInfo:\n        \"\"\"\n        Create a new backup snapshot.\n    \n        Args:\n            source_path: Path to directory or file to backup\n            tags: Optional tags for the snapshot\n    \n        Returns:\n            SnapshotInfo for the created snapshot\n    \n        Raises:\n            SnapshotError: If snapshot creation fails\n        \"\"\"\n        try:\n            source_path = Path(source_path).resolve()\n            if not source_path.exists():\n                raise SnapshotError(f\"Source path does not exist: {source_path}\")\n    \n            # Generate snapshot ID\n            snapshot_id = self._generate_snapshot_id()\n    \n            # Get parent snapshot for incremental backup\n            parent_id = self._get_latest_snapshot_id(source_path)\n            parent_files = self._get_snapshot_files(parent_id) if parent_id else {}\n    \n            # Scan files in source\n            current_files = self._scan_source_files(source_path)\n    \n            # Calculate changes\n            changes = self._calculate_changes(parent_files, current_files)\n    \n            # Store chunks for new/modified files\n            stored_files = self._store_file_chunks(current_files, changes)\n    \n            # Create snapshot info\n            snapshot = SnapshotInfo(\n                id=snapshot_id,\n                timestamp=datetime.now(),\n                source_path=source_path,\n                parent_id=parent_id,\n                files=list(stored_files.values()),\n                changes=changes,\n                tags=tags or set()\n            )\n    \n            # Store snapshot metadata\n            self._store_snapshot_metadata(snapshot)\n    \n            return snapshot\n    \n        except Exception as e:\n>           raise SnapshotError(f\"Failed to create snapshot: {e}\")\nE           common.core.exceptions.SnapshotError: Failed to create snapshot: 'str' object has no attribute 'match'\n\ncommon/core/backup_engine.py:135: SnapshotError\n\nDuring handling of the above exception, another exception occurred:\n\nbackup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>\nproject_dir = PosixPath('/tmp/tmp4har2wl4/test_project')\n\n    def test_get_version_diff(backup_engine, project_dir):\n        \"\"\"Test getting differences between two versions.\"\"\"\n        # Create an initial backup\n>       initial_version = backup_engine.create_backup(name=\"initial\")\n\ntests/game_developer/backup_engine/test_engine.py:178: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c34d8a0>\nname = 'initial', version_type = <GameVersionType.DEVELOPMENT: 'development'>\ndescription = None, is_milestone = False, tags = None\n\n    def create_backup(\n        self,\n        name: str,\n        version_type: GameVersionType = GameVersionType.DEVELOPMENT,\n        description: Optional[str] = None,\n        is_milestone: bool = False,\n        tags: Optional[List[str]] = None\n    ) -> ProjectVersion:\n        \"\"\"\n        Create a backup of the project using unified engine infrastructure.\n    \n        Args:\n            name: Name of the backup version\n            version_type: Type of the version\n            description: Description of the version\n            is_milestone: Whether this version is a milestone\n            tags: List of tags for this version\n    \n        Returns:\n            ProjectVersion: The created version\n        \"\"\"\n        try:\n            # Convert tags to set for common engine\n            snapshot_tags = set(tags) if tags else set()\n            snapshot_tags.add(f\"version_type:{version_type.value}\")\n            if is_milestone:\n                snapshot_tags.add(\"milestone\")\n    \n            # Create snapshot using common engine\n            snapshot = self.create_snapshot(\n                source_path=self.project_path,\n                tags=snapshot_tags\n            )\n    \n            # Convert snapshot to ProjectVersion for game-specific interface\n            project_version = ProjectVersion.from_common_snapshot_info(\n                snapshot=snapshot,\n                name=name,\n                version_type=version_type,\n                is_milestone=is_milestone\n            )\n    \n            # Store game-specific metadata in the version tracker\n            self.version_tracker.store_version_metadata(project_version)\n    \n            return project_version\n    \n        except Exception as e:\n>           raise BackupSystemError(f\"Failed to create backup: {e}\")\nE           common.core.exceptions.BackupSystemError: Failed to create backup: Failed to create snapshot: 'str' object has no attribute 'match'\n\ngamevault/backup_engine/engine.py:285: BackupSystemError"}, "teardown": {"duration": 0.0005905721336603165, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_engine.py::test_get_storage_stats", "lineno": 198, "outcome": "failed", "keywords": ["test_get_storage_stats", "test_engine.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0010125599801540375, "outcome": "passed"}, "call": {"duration": 0.00019175885245203972, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_engine.py", "lineno": 203, "message": "KeyError: 'total'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_engine.py", "lineno": 203, "message": "KeyError"}], "longrepr": "backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974c2aa380>\nproject_dir = PosixPath('/tmp/tmpkjsveir7/test_project')\n\n    def test_get_storage_stats(backup_engine, project_dir):\n        \"\"\"Test getting storage statistics.\"\"\"\n        # Initially should have no storage used\n        stats_before = backup_engine.get_storage_stats()\n>       assert stats_before[\"total\"] == 0\nE       KeyError: 'total'\n\ntests/game_developer/backup_engine/test_engine.py:203: KeyError"}, "teardown": {"duration": 0.0005756649188697338, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_store_file", "lineno": 45, "outcome": "failed", "keywords": ["test_store_file", "test_storage.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0004798988811671734, "outcome": "passed"}, "call": {"duration": 0.000342600978910923, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_storage.py", "lineno": 49, "message": ""}, {"path": "gamevault/backup_engine/storage.py", "lineno": 99, "message": "in store_file"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nstorage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974eb507c0>\nsample_file = '/tmp/tmplhd4k7n1'\n\n    def test_store_file(storage_manager, sample_file):\n        \"\"\"Test storing a file in the storage manager.\"\"\"\n        # Store the file\n>       file_id, storage_path = storage_manager.store_file(sample_file)\n\ntests/game_developer/backup_engine/test_storage.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/backup_engine/storage.py:99: in store_file\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00036321813240647316, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_retrieve_file", "lineno": 58, "outcome": "failed", "keywords": ["test_retrieve_file", "test_storage.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00047611165791749954, "outcome": "passed"}, "call": {"duration": 0.0003170478157699108, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_storage.py", "lineno": 62, "message": ""}, {"path": "gamevault/backup_engine/storage.py", "lineno": 99, "message": "in store_file"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nstorage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974c2b1ba0>\nsample_file = '/tmp/tmpwmilcq2i'\n\n    def test_retrieve_file(storage_manager, sample_file):\n        \"\"\"Test retrieving a stored file.\"\"\"\n        # Store the file\n>       file_id, _ = storage_manager.store_file(sample_file)\n\ntests/game_developer/backup_engine/test_storage.py:62: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/backup_engine/storage.py:99: in store_file\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00035206181928515434, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_store_and_retrieve_chunks", "lineno": 82, "outcome": "failed", "keywords": ["test_store_and_retrieve_chunks", "test_storage.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00038496917113661766, "outcome": "passed"}, "call": {"duration": 0.00023359106853604317, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_storage.py", "lineno": 88, "message": ""}, {"path": "gamevault/backup_engine/storage.py", "lineno": 150, "message": "in store_chunk"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'Chunk 1 data', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nstorage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974c2d3c70>\nsample_chunks = [b'Chunk 1 data', b'Chunk 2 data with more content', b'Another chunk with different content']\n\n    def test_store_and_retrieve_chunks(storage_manager, sample_chunks):\n        \"\"\"Test storing and retrieving chunks.\"\"\"\n        # Store the chunks\n        chunk_ids = []\n        for chunk in sample_chunks:\n>           chunk_id = storage_manager.store_chunk(chunk)\n\ntests/game_developer/backup_engine/test_storage.py:88: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/backup_engine/storage.py:150: in store_chunk\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'Chunk 1 data', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00033592572435736656, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_remove_file", "lineno": 100, "outcome": "failed", "keywords": ["test_remove_file", "test_storage.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0004802411422133446, "outcome": "passed"}, "call": {"duration": 0.00031071482226252556, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_storage.py", "lineno": 104, "message": ""}, {"path": "gamevault/backup_engine/storage.py", "lineno": 99, "message": "in store_file"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nstorage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974e7f9a50>\nsample_file = '/tmp/tmpmefd9gy_'\n\n    def test_remove_file(storage_manager, sample_file):\n        \"\"\"Test removing a stored file.\"\"\"\n        # Store the file\n>       file_id, _ = storage_manager.store_file(sample_file)\n\ntests/game_developer/backup_engine/test_storage.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/backup_engine/storage.py:99: in store_file\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0003568790853023529, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_remove_chunk", "lineno": 120, "outcome": "failed", "keywords": ["test_remove_chunk", "test_storage.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00037600891664624214, "outcome": "passed"}, "call": {"duration": 0.00023327814415097237, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_storage.py", "lineno": 124, "message": ""}, {"path": "gamevault/backup_engine/storage.py", "lineno": 150, "message": "in store_chunk"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'Chunk 1 data', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nstorage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974e936440>\nsample_chunks = [b'Chunk 1 data', b'Chunk 2 data with more content', b'Another chunk with different content']\n\n    def test_remove_chunk(storage_manager, sample_chunks):\n        \"\"\"Test removing a stored chunk.\"\"\"\n        # Store a chunk\n>       chunk_id = storage_manager.store_chunk(sample_chunks[0])\n\ntests/game_developer/backup_engine/test_storage.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/backup_engine/storage.py:150: in store_chunk\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'Chunk 1 data', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00033059343695640564, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_get_storage_size", "lineno": 140, "outcome": "failed", "keywords": ["test_get_storage_size", "test_storage.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0005070716142654419, "outcome": "passed"}, "call": {"duration": 0.00036757299676537514, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_storage.py", "lineno": 150, "message": ""}, {"path": "gamevault/backup_engine/storage.py", "lineno": 99, "message": "in store_file"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nstorage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974eace440>\nsample_file = '/tmp/tmpiystuuvv'\nsample_chunks = [b'Chunk 1 data', b'Chunk 2 data with more content', b'Another chunk with different content']\n\n    def test_get_storage_size(storage_manager, sample_file, sample_chunks):\n        \"\"\"Test getting storage size information.\"\"\"\n        # Initially, storage should be empty\n        sizes = storage_manager.get_storage_size()\n        assert sizes[\"files\"] == 0\n        assert sizes[\"chunks\"] == 0\n        assert sizes[\"total\"] == 0\n    \n        # Store a file\n>       storage_manager.store_file(sample_file)\n\ntests/game_developer/backup_engine/test_storage.py:150: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/backup_engine/storage.py:99: in store_file\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0003649727441370487, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_file_not_found", "lineno": 164, "outcome": "passed", "keywords": ["test_file_not_found", "test_storage.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0003250027075409889, "outcome": "passed"}, "call": {"duration": 0.00023009488359093666, "outcome": "passed"}, "teardown": {"duration": 0.00026408489793539047, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_chunk_not_found", "lineno": 170, "outcome": "passed", "keywords": ["test_chunk_not_found", "test_storage.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0003158748149871826, "outcome": "passed"}, "call": {"duration": 0.00023461412638425827, "outcome": "passed"}, "teardown": {"duration": 0.00027444399893283844, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_storage.py::test_idempotent_storage", "lineno": 176, "outcome": "failed", "keywords": ["test_idempotent_storage", "test_storage.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0004669390618801117, "outcome": "passed"}, "call": {"duration": 0.0003005662001669407, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_storage.py", "lineno": 180, "message": ""}, {"path": "gamevault/backup_engine/storage.py", "lineno": 99, "message": "in store_file"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nstorage_manager = <gamevault.backup_engine.storage.StorageManager object at 0x7f974e854790>\nsample_file = '/tmp/tmpflg6d2s1'\n\n    def test_idempotent_storage(storage_manager, sample_file):\n        \"\"\"Test that storing the same file multiple times is idempotent.\"\"\"\n        # Store the file twice\n>       file_id1, storage_path1 = storage_manager.store_file(sample_file)\n\ntests/game_developer/backup_engine/test_storage.py:180: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/backup_engine/storage.py:99: in store_file\n    compressed_data = compress_data(data, self.compression_level)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'Sample file content for testing', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0003549898974597454, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_create_version", "lineno": 53, "outcome": "error", "keywords": ["test_create_version", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0004921639338135719, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError"}], "longrepr": "@pytest.fixture\n    def sample_files():\n        \"\"\"Create sample file info for testing.\"\"\"\n        return {\n>           \"file1.txt\": FileInfo(\n                path=\"file1.txt\",\n                size=100,\n                hash=\"hash1\",\n                modified_time=1000.0,\n                is_binary=False,\n                storage_path=\"/path/to/file1.txt\"\n            ),\n            \"file2.bin\": FileInfo(\n                path=\"file2.bin\",\n                size=200,\n                hash=\"hash2\",\n                modified_time=1001.0,\n                is_binary=True,\n                chunks=[\"chunk1\", \"chunk2\"]\n            ),\n            \"file3.png\": FileInfo(\n                path=\"file3.png\",\n                size=300,\n                hash=\"hash3\",\n                modified_time=1002.0,\n                is_binary=True,\n                chunks=[\"chunk3\", \"chunk4\"]\n            )\n        }\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/backup_engine/test_version_tracker.py:27: TypeError"}, "teardown": {"duration": 0.00026074470952153206, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_create_version_with_parent", "lineno": 86, "outcome": "error", "keywords": ["test_create_version_with_parent", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0004553571343421936, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError"}], "longrepr": "@pytest.fixture\n    def sample_files():\n        \"\"\"Create sample file info for testing.\"\"\"\n        return {\n>           \"file1.txt\": FileInfo(\n                path=\"file1.txt\",\n                size=100,\n                hash=\"hash1\",\n                modified_time=1000.0,\n                is_binary=False,\n                storage_path=\"/path/to/file1.txt\"\n            ),\n            \"file2.bin\": FileInfo(\n                path=\"file2.bin\",\n                size=200,\n                hash=\"hash2\",\n                modified_time=1001.0,\n                is_binary=True,\n                chunks=[\"chunk1\", \"chunk2\"]\n            ),\n            \"file3.png\": FileInfo(\n                path=\"file3.png\",\n                size=300,\n                hash=\"hash3\",\n                modified_time=1002.0,\n                is_binary=True,\n                chunks=[\"chunk3\", \"chunk4\"]\n            )\n        }\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/backup_engine/test_version_tracker.py:27: TypeError"}, "teardown": {"duration": 0.00027316389605402946, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_version", "lineno": 113, "outcome": "error", "keywords": ["test_get_version", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0004523252137005329, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError"}], "longrepr": "@pytest.fixture\n    def sample_files():\n        \"\"\"Create sample file info for testing.\"\"\"\n        return {\n>           \"file1.txt\": FileInfo(\n                path=\"file1.txt\",\n                size=100,\n                hash=\"hash1\",\n                modified_time=1000.0,\n                is_binary=False,\n                storage_path=\"/path/to/file1.txt\"\n            ),\n            \"file2.bin\": FileInfo(\n                path=\"file2.bin\",\n                size=200,\n                hash=\"hash2\",\n                modified_time=1001.0,\n                is_binary=True,\n                chunks=[\"chunk1\", \"chunk2\"]\n            ),\n            \"file3.png\": FileInfo(\n                path=\"file3.png\",\n                size=300,\n                hash=\"hash3\",\n                modified_time=1002.0,\n                is_binary=True,\n                chunks=[\"chunk3\", \"chunk4\"]\n            )\n        }\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/backup_engine/test_version_tracker.py:27: TypeError"}, "teardown": {"duration": 0.00026176078245043755, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_list_versions", "lineno": 130, "outcome": "error", "keywords": ["test_list_versions", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00046215299516916275, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError"}], "longrepr": "@pytest.fixture\n    def sample_files():\n        \"\"\"Create sample file info for testing.\"\"\"\n        return {\n>           \"file1.txt\": FileInfo(\n                path=\"file1.txt\",\n                size=100,\n                hash=\"hash1\",\n                modified_time=1000.0,\n                is_binary=False,\n                storage_path=\"/path/to/file1.txt\"\n            ),\n            \"file2.bin\": FileInfo(\n                path=\"file2.bin\",\n                size=200,\n                hash=\"hash2\",\n                modified_time=1001.0,\n                is_binary=True,\n                chunks=[\"chunk1\", \"chunk2\"]\n            ),\n            \"file3.png\": FileInfo(\n                path=\"file3.png\",\n                size=300,\n                hash=\"hash3\",\n                modified_time=1002.0,\n                is_binary=True,\n                chunks=[\"chunk3\", \"chunk4\"]\n            )\n        }\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/backup_engine/test_version_tracker.py:27: TypeError"}, "teardown": {"duration": 0.00026073725894093513, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_version_history", "lineno": 145, "outcome": "error", "keywords": ["test_get_version_history", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00045760627835989, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError"}], "longrepr": "@pytest.fixture\n    def sample_files():\n        \"\"\"Create sample file info for testing.\"\"\"\n        return {\n>           \"file1.txt\": FileInfo(\n                path=\"file1.txt\",\n                size=100,\n                hash=\"hash1\",\n                modified_time=1000.0,\n                is_binary=False,\n                storage_path=\"/path/to/file1.txt\"\n            ),\n            \"file2.bin\": FileInfo(\n                path=\"file2.bin\",\n                size=200,\n                hash=\"hash2\",\n                modified_time=1001.0,\n                is_binary=True,\n                chunks=[\"chunk1\", \"chunk2\"]\n            ),\n            \"file3.png\": FileInfo(\n                path=\"file3.png\",\n                size=300,\n                hash=\"hash3\",\n                modified_time=1002.0,\n                is_binary=True,\n                chunks=[\"chunk3\", \"chunk4\"]\n            )\n        }\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/backup_engine/test_version_tracker.py:27: TypeError"}, "teardown": {"duration": 0.00026297615841031075, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_milestones", "lineno": 162, "outcome": "error", "keywords": ["test_get_milestones", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00045257387682795525, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError"}], "longrepr": "@pytest.fixture\n    def sample_files():\n        \"\"\"Create sample file info for testing.\"\"\"\n        return {\n>           \"file1.txt\": FileInfo(\n                path=\"file1.txt\",\n                size=100,\n                hash=\"hash1\",\n                modified_time=1000.0,\n                is_binary=False,\n                storage_path=\"/path/to/file1.txt\"\n            ),\n            \"file2.bin\": FileInfo(\n                path=\"file2.bin\",\n                size=200,\n                hash=\"hash2\",\n                modified_time=1001.0,\n                is_binary=True,\n                chunks=[\"chunk1\", \"chunk2\"]\n            ),\n            \"file3.png\": FileInfo(\n                path=\"file3.png\",\n                size=300,\n                hash=\"hash3\",\n                modified_time=1002.0,\n                is_binary=True,\n                chunks=[\"chunk3\", \"chunk4\"]\n            )\n        }\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/backup_engine/test_version_tracker.py:27: TypeError"}, "teardown": {"duration": 0.0002688821405172348, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_versions_by_tag", "lineno": 180, "outcome": "error", "keywords": ["test_get_versions_by_tag", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.000451910775154829, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError"}], "longrepr": "@pytest.fixture\n    def sample_files():\n        \"\"\"Create sample file info for testing.\"\"\"\n        return {\n>           \"file1.txt\": FileInfo(\n                path=\"file1.txt\",\n                size=100,\n                hash=\"hash1\",\n                modified_time=1000.0,\n                is_binary=False,\n                storage_path=\"/path/to/file1.txt\"\n            ),\n            \"file2.bin\": FileInfo(\n                path=\"file2.bin\",\n                size=200,\n                hash=\"hash2\",\n                modified_time=1001.0,\n                is_binary=True,\n                chunks=[\"chunk1\", \"chunk2\"]\n            ),\n            \"file3.png\": FileInfo(\n                path=\"file3.png\",\n                size=300,\n                hash=\"hash3\",\n                modified_time=1002.0,\n                is_binary=True,\n                chunks=[\"chunk3\", \"chunk4\"]\n            )\n        }\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/backup_engine/test_version_tracker.py:27: TypeError"}, "teardown": {"duration": 0.0002686642110347748, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_get_versions_by_type", "lineno": 203, "outcome": "error", "keywords": ["test_get_versions_by_type", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00047806231305003166, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError"}], "longrepr": "@pytest.fixture\n    def sample_files():\n        \"\"\"Create sample file info for testing.\"\"\"\n        return {\n>           \"file1.txt\": FileInfo(\n                path=\"file1.txt\",\n                size=100,\n                hash=\"hash1\",\n                modified_time=1000.0,\n                is_binary=False,\n                storage_path=\"/path/to/file1.txt\"\n            ),\n            \"file2.bin\": FileInfo(\n                path=\"file2.bin\",\n                size=200,\n                hash=\"hash2\",\n                modified_time=1001.0,\n                is_binary=True,\n                chunks=[\"chunk1\", \"chunk2\"]\n            ),\n            \"file3.png\": FileInfo(\n                path=\"file3.png\",\n                size=300,\n                hash=\"hash3\",\n                modified_time=1002.0,\n                is_binary=True,\n                chunks=[\"chunk3\", \"chunk4\"]\n            )\n        }\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/backup_engine/test_version_tracker.py:27: TypeError"}, "teardown": {"duration": 0.00026137009263038635, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_delete_version", "lineno": 238, "outcome": "error", "keywords": ["test_delete_version", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00045934924855828285, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'"}, "traceback": [{"path": "tests/game_developer/backup_engine/test_version_tracker.py", "lineno": 27, "message": "TypeError"}], "longrepr": "@pytest.fixture\n    def sample_files():\n        \"\"\"Create sample file info for testing.\"\"\"\n        return {\n>           \"file1.txt\": FileInfo(\n                path=\"file1.txt\",\n                size=100,\n                hash=\"hash1\",\n                modified_time=1000.0,\n                is_binary=False,\n                storage_path=\"/path/to/file1.txt\"\n            ),\n            \"file2.bin\": FileInfo(\n                path=\"file2.bin\",\n                size=200,\n                hash=\"hash2\",\n                modified_time=1001.0,\n                is_binary=True,\n                chunks=[\"chunk1\", \"chunk2\"]\n            ),\n            \"file3.png\": FileInfo(\n                path=\"file3.png\",\n                size=300,\n                hash=\"hash3\",\n                modified_time=1002.0,\n                is_binary=True,\n                chunks=[\"chunk3\", \"chunk4\"]\n            )\n        }\nE       TypeError: FileInfo.__init__() got an unexpected keyword argument 'is_binary'\n\ntests/game_developer/backup_engine/test_version_tracker.py:27: TypeError"}, "teardown": {"duration": 0.00026072701439261436, "outcome": "passed"}}, {"nodeid": "tests/game_developer/backup_engine/test_version_tracker.py::test_version_not_found", "lineno": 266, "outcome": "passed", "keywords": ["test_version_not_found", "test_version_tracker.py", "backup_engine", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0003861011937260628, "outcome": "passed"}, "call": {"duration": 0.00019183196127414703, "outcome": "passed"}, "teardown": {"duration": 0.00021892506629228592, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_common_terms", "lineno": 137, "outcome": "passed", "keywords": ["test_get_common_terms", "test_analysis.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.001342330127954483, "outcome": "passed"}, "call": {"duration": 0.0004990845918655396, "outcome": "passed"}, "teardown": {"duration": 0.00016533583402633667, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_feedback_over_time", "lineno": 161, "outcome": "passed", "keywords": ["test_get_feedback_over_time", "test_analysis.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0012560556642711163, "outcome": "passed"}, "call": {"duration": 0.00033262092620134354, "outcome": "passed"}, "teardown": {"duration": 0.00017111608758568764, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_identify_recurring_issues", "lineno": 180, "outcome": "passed", "keywords": ["test_identify_recurring_issues", "test_analysis.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0011972486972808838, "outcome": "passed"}, "call": {"duration": 0.0002998760901391506, "outcome": "passed"}, "teardown": {"duration": 0.0001893211156129837, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_sentiment_distribution", "lineno": 198, "outcome": "passed", "keywords": ["test_get_sentiment_distribution", "test_analysis.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0010338150896131992, "outcome": "passed"}, "call": {"duration": 0.00020743301138281822, "outcome": "passed"}, "teardown": {"duration": 0.00016535399481654167, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_analyze_feature_feedback", "lineno": 213, "outcome": "passed", "keywords": ["test_analyze_feature_feedback", "test_analysis.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0012052240781486034, "outcome": "passed"}, "call": {"duration": 0.00033360905945301056, "outcome": "passed"}, "teardown": {"duration": 0.00017641577869653702, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_player_engagement", "lineno": 227, "outcome": "passed", "keywords": ["test_get_player_engagement", "test_analysis.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0011806669645011425, "outcome": "passed"}, "call": {"duration": 0.0002646949142217636, "outcome": "passed"}, "teardown": {"duration": 0.0001751026138663292, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_analysis.py::test_get_player_engagement_no_feedback", "lineno": 247, "outcome": "passed", "keywords": ["test_get_player_engagement_no_feedback", "test_analysis.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0010847500525414944, "outcome": "passed"}, "call": {"duration": 0.00020353589206933975, "outcome": "passed"}, "teardown": {"duration": 0.00017311284318566322, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_add_feedback", "lineno": 37, "outcome": "passed", "keywords": ["test_add_feedback", "test_database.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.023672599345445633, "outcome": "passed"}, "call": {"duration": 0.002771671861410141, "outcome": "passed"}, "teardown": {"duration": 0.0002710050903260708, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_update_feedback", "lineno": 60, "outcome": "passed", "keywords": ["test_update_feedback", "test_database.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.022354972083121538, "outcome": "passed"}, "call": {"duration": 0.005099637899547815, "outcome": "passed"}, "teardown": {"duration": 0.00029282085597515106, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_delete_feedback", "lineno": 87, "outcome": "passed", "keywords": ["test_delete_feedback", "test_database.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.02204849384725094, "outcome": "passed"}, "call": {"duration": 0.004904992878437042, "outcome": "passed"}, "teardown": {"duration": 0.0002751699648797512, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_list_feedback", "lineno": 107, "outcome": "passed", "keywords": ["test_list_feedback", "test_database.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.02108245389536023, "outcome": "passed"}, "call": {"duration": 0.010247464757412672, "outcome": "passed"}, "teardown": {"duration": 0.00029659178107976913, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_count_feedback", "lineno": 183, "outcome": "passed", "keywords": ["test_count_feedback", "test_database.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.022017883136868477, "outcome": "passed"}, "call": {"duration": 0.004849507939070463, "outcome": "passed"}, "teardown": {"duration": 0.00026097800582647324, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_get_feedback_by_versions", "lineno": 224, "outcome": "passed", "keywords": ["test_get_feedback_by_versions", "test_database.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.020560139790177345, "outcome": "passed"}, "call": {"duration": 0.007183060050010681, "outcome": "passed"}, "teardown": {"duration": 0.00025879405438899994, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_get_feedback_stats", "lineno": 273, "outcome": "passed", "keywords": ["test_get_feedback_stats", "test_database.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.021809309720993042, "outcome": "passed"}, "call": {"duration": 0.011022572871297598, "outcome": "passed"}, "teardown": {"duration": 0.0002569272182881832, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_database.py::test_update_nonexistent_feedback", "lineno": 313, "outcome": "passed", "keywords": ["test_update_nonexistent_feedback", "test_database.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.02232599165290594, "outcome": "passed"}, "call": {"duration": 0.0003662407398223877, "outcome": "passed"}, "teardown": {"duration": 0.00028837891295552254, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_add_feedback", "lineno": 44, "outcome": "passed", "keywords": ["test_add_feedback", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.022273996844887733, "outcome": "passed"}, "call": {"duration": 0.002832793164998293, "outcome": "passed"}, "teardown": {"duration": 0.00029134098440408707, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_add_feedback_invalid_version", "lineno": 73, "outcome": "passed", "keywords": ["test_add_feedback_invalid_version", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.02164861187338829, "outcome": "passed"}, "call": {"duration": 0.0003472329117357731, "outcome": "passed"}, "teardown": {"duration": 0.00029126740992069244, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_update_feedback", "lineno": 85, "outcome": "passed", "keywords": ["test_update_feedback", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.020976772997528315, "outcome": "passed"}, "call": {"duration": 0.004547224845737219, "outcome": "passed"}, "teardown": {"duration": 0.00028873514384031296, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_delete_feedback", "lineno": 110, "outcome": "passed", "keywords": ["test_delete_feedback", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.021723605692386627, "outcome": "passed"}, "call": {"duration": 0.004498946946114302, "outcome": "passed"}, "teardown": {"duration": 0.0002876049838960171, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_mark_feedback_resolved", "lineno": 131, "outcome": "passed", "keywords": ["test_mark_feedback_resolved", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.022049979772418737, "outcome": "passed"}, "call": {"duration": 0.006885382812470198, "outcome": "passed"}, "teardown": {"duration": 0.00029185740277171135, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_add_tags_to_feedback", "lineno": 159, "outcome": "passed", "keywords": ["test_add_tags_to_feedback", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.022496121004223824, "outcome": "passed"}, "call": {"duration": 0.007609735708683729, "outcome": "passed"}, "teardown": {"duration": 0.0002930629998445511, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_remove_tags_from_feedback", "lineno": 186, "outcome": "passed", "keywords": ["test_remove_tags_from_feedback", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.021917962934821844, "outcome": "passed"}, "call": {"duration": 0.0047647650353610516, "outcome": "passed"}, "teardown": {"duration": 0.00031777797266840935, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_add_metadata_to_feedback", "lineno": 208, "outcome": "passed", "keywords": ["test_add_metadata_to_feedback", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.021780797746032476, "outcome": "passed"}, "call": {"duration": 0.00737358583137393, "outcome": "passed"}, "teardown": {"duration": 0.0002980991266667843, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_get_feedback_for_version", "lineno": 235, "outcome": "passed", "keywords": ["test_get_feedback_for_version", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.021970164962112904, "outcome": "passed"}, "call": {"duration": 0.015921554993838072, "outcome": "passed"}, "teardown": {"duration": 0.0002929661422967911, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_get_feedback_for_invalid_version", "lineno": 265, "outcome": "passed", "keywords": ["test_get_feedback_for_invalid_version", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.023007940966635942, "outcome": "passed"}, "call": {"duration": 0.00023400317877531052, "outcome": "passed"}, "teardown": {"duration": 0.000277969054877758, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_get_feedback_for_player", "lineno": 271, "outcome": "passed", "keywords": ["test_get_feedback_for_player", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.02169808791950345, "outcome": "passed"}, "call": {"duration": 0.012066251132637262, "outcome": "passed"}, "teardown": {"duration": 0.00028961803764104843, "outcome": "passed"}}, {"nodeid": "tests/game_developer/feedback_system/test_manager.py::test_search_feedback", "lineno": 292, "outcome": "passed", "keywords": ["test_search_feedback", "test_manager.py", "feedback_system", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.022506405133754015, "outcome": "passed"}, "call": {"duration": 0.009712005965411663, "outcome": "passed"}, "teardown": {"duration": 0.0003039618022739887, "outcome": "passed"}}, {"nodeid": "tests/game_developer/integration/test_game_development_workflow.py::test_complete_game_development_cycle", "lineno": 110, "outcome": "error", "keywords": ["test_complete_game_development_cycle", "test_game_development_workflow.py", "integration", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0014621666632592678, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/integration/test_game_development_workflow.py", "lineno": 79, "message": "AttributeError: 'BackupEngine' object has no attribute 'storage_dir'"}, "traceback": [{"path": "tests/game_developer/integration/test_game_development_workflow.py", "lineno": 79, "message": "AttributeError"}], "longrepr": "backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e841e70>\n\n    @pytest.fixture\n    def feedback_manager(backup_engine):\n        \"\"\"Create a feedback manager instance.\"\"\"\n        return FeedbackManager(\n            project_name=\"test_game\",\n            version_tracker=backup_engine.version_tracker,\n>           storage_dir=backup_engine.storage_dir\n        )\nE       AttributeError: 'BackupEngine' object has no attribute 'storage_dir'\n\ntests/game_developer/integration/test_game_development_workflow.py:79: AttributeError"}, "teardown": {"duration": 0.000658783596009016, "outcome": "passed"}}, {"nodeid": "tests/game_developer/integration/test_game_development_workflow.py::test_milestone_annotations", "lineno": 368, "outcome": "error", "keywords": ["test_milestone_annotations", "test_game_development_workflow.py", "integration", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0011933622881770134, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/integration/test_game_development_workflow.py", "lineno": 89, "message": "AttributeError: 'BackupEngine' object has no attribute 'storage_dir'"}, "traceback": [{"path": "tests/game_developer/integration/test_game_development_workflow.py", "lineno": 89, "message": "AttributeError"}], "longrepr": "backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e8418d0>\n\n    @pytest.fixture\n    def milestone_manager(backup_engine):\n        \"\"\"Create a milestone manager instance.\"\"\"\n        return MilestoneManager(\n            project_name=\"test_game\",\n            backup_engine=backup_engine,\n>           storage_dir=backup_engine.storage_dir\n        )\nE       AttributeError: 'BackupEngine' object has no attribute 'storage_dir'\n\ntests/game_developer/integration/test_game_development_workflow.py:89: AttributeError"}, "teardown": {"duration": 0.0006441003642976284, "outcome": "passed"}}, {"nodeid": "tests/game_developer/integration/test_game_development_workflow.py::test_platform_specific_features", "lineno": 422, "outcome": "error", "keywords": ["test_platform_specific_features", "test_game_development_workflow.py", "integration", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.001149218063801527, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/integration/test_game_development_workflow.py", "lineno": 98, "message": "AttributeError: 'BackupEngine' object has no attribute 'storage_dir'"}, "traceback": [{"path": "tests/game_developer/integration/test_game_development_workflow.py", "lineno": 98, "message": "AttributeError"}], "longrepr": "backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e855cc0>\n\n    @pytest.fixture\n    def platform_config_manager(backup_engine):\n        \"\"\"Create a platform configuration manager instance.\"\"\"\n        return PlatformConfigManager(\n            project_name=\"test_game\",\n>           storage_dir=backup_engine.storage_dir\n        )\nE       AttributeError: 'BackupEngine' object has no attribute 'storage_dir'\n\ntests/game_developer/integration/test_game_development_workflow.py:98: AttributeError"}, "teardown": {"duration": 0.000639861449599266, "outcome": "passed"}}, {"nodeid": "tests/game_developer/integration/test_game_development_workflow.py::test_configuration_management_across_platforms", "lineno": 487, "outcome": "error", "keywords": ["test_configuration_management_across_platforms", "test_game_development_workflow.py", "integration", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0011226092465221882, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/integration/test_game_development_workflow.py", "lineno": 98, "message": "AttributeError: 'BackupEngine' object has no attribute 'storage_dir'"}, "traceback": [{"path": "tests/game_developer/integration/test_game_development_workflow.py", "lineno": 98, "message": "AttributeError"}], "longrepr": "backup_engine = <gamevault.backup_engine.engine.BackupEngine object at 0x7f974e9376d0>\n\n    @pytest.fixture\n    def platform_config_manager(backup_engine):\n        \"\"\"Create a platform configuration manager instance.\"\"\"\n        return PlatformConfigManager(\n            project_name=\"test_game\",\n>           storage_dir=backup_engine.storage_dir\n        )\nE       AttributeError: 'BackupEngine' object has no attribute 'storage_dir'\n\ntests/game_developer/integration/test_game_development_workflow.py:98: AttributeError"}, "teardown": {"duration": 0.0008529620245099068, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_create_milestone", "lineno": 137, "outcome": "passed", "keywords": ["test_create_milestone", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0030149859376251698, "outcome": "passed"}, "call": {"duration": 0.0005537513643503189, "outcome": "passed"}, "teardown": {"duration": 0.0003179619088768959, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_create_milestone_no_backup_engine", "lineno": 175, "outcome": "passed", "keywords": ["test_create_milestone_no_backup_engine", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0017207376658916473, "outcome": "passed"}, "call": {"duration": 0.0011652600951492786, "outcome": "passed"}, "teardown": {"duration": 0.00015153968706727028, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_get_milestone", "lineno": 227, "outcome": "passed", "keywords": ["test_get_milestone", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.002525803167372942, "outcome": "passed"}, "call": {"duration": 0.00043750088661909103, "outcome": "passed"}, "teardown": {"duration": 0.00031847693026065826, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_get_nonexistent_milestone", "lineno": 259, "outcome": "passed", "keywords": ["test_get_nonexistent_milestone", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.002525647636502981, "outcome": "passed"}, "call": {"duration": 0.0002414933405816555, "outcome": "passed"}, "teardown": {"duration": 0.00030522793531417847, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_update_milestone_annotations", "lineno": 265, "outcome": "passed", "keywords": ["test_update_milestone_annotations", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00248914398252964, "outcome": "passed"}, "call": {"duration": 0.0005209748633205891, "outcome": "passed"}, "teardown": {"duration": 0.0003260252997279167, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_update_nonexistent_milestone", "lineno": 303, "outcome": "passed", "keywords": ["test_update_nonexistent_milestone", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00249659875407815, "outcome": "passed"}, "call": {"duration": 0.00020757922902703285, "outcome": "passed"}, "teardown": {"duration": 0.00029910309240221977, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_list_milestones", "lineno": 309, "outcome": "passed", "keywords": ["test_list_milestones", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0025938046164810658, "outcome": "passed"}, "call": {"duration": 0.00102970190346241, "outcome": "passed"}, "teardown": {"duration": 0.00032876431941986084, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_restore_milestone", "lineno": 350, "outcome": "passed", "keywords": ["test_restore_milestone", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0033956291154026985, "outcome": "passed"}, "call": {"duration": 0.00041713379323482513, "outcome": "passed"}, "teardown": {"duration": 0.0003034002147614956, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_restore_without_backup_engine", "lineno": 374, "outcome": "passed", "keywords": ["test_restore_without_backup_engine", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00135337607935071, "outcome": "passed"}, "call": {"duration": 0.00040829088538885117, "outcome": "passed"}, "teardown": {"duration": 0.00016065780073404312, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_compare_milestones", "lineno": 383, "outcome": "passed", "keywords": ["test_compare_milestones", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0024689030833542347, "outcome": "passed"}, "call": {"duration": 0.0003612358123064041, "outcome": "passed"}, "teardown": {"duration": 0.0003009098581969738, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_compare_with_annotation_changes", "lineno": 404, "outcome": "passed", "keywords": ["test_compare_with_annotation_changes", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.002461870200932026, "outcome": "passed"}, "call": {"duration": 0.000687026884406805, "outcome": "passed"}, "teardown": {"duration": 0.00033061811700463295, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_delete_milestone", "lineno": 453, "outcome": "passed", "keywords": ["test_delete_milestone", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0024139881134033203, "outcome": "passed"}, "call": {"duration": 0.0008116541430354118, "outcome": "passed"}, "teardown": {"duration": 0.00032892124727368355, "outcome": "passed"}}, {"nodeid": "tests/game_developer/milestone_management/test_manager.py::test_get_milestone_timeline", "lineno": 481, "outcome": "passed", "keywords": ["test_get_milestone_timeline", "test_manager.py", "milestone_management", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0025183907710015774, "outcome": "passed"}, "call": {"duration": 0.0005794200114905834, "outcome": "passed"}, "teardown": {"duration": 0.000359910074621439, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_initial_backup_performance[100-100]", "lineno": 139, "outcome": "skipped", "keywords": ["test_initial_backup_performance[100-100]", "parametrize", "pytestmark", "100-100", "skip", "test_backup_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00015119090676307678, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_backup_performance.py', 140, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.0001282370649278164, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_initial_backup_performance[500-200]", "lineno": 139, "outcome": "skipped", "keywords": ["test_initial_backup_performance[500-200]", "parametrize", "pytestmark", "500-200", "skip", "test_backup_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0001286882907152176, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_backup_performance.py', 140, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.00011928007006645203, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_incremental_backup_performance", "lineno": 183, "outcome": "skipped", "keywords": ["test_incremental_backup_performance", "skip", "test_backup_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00010848604142665863, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_backup_performance.py', 184, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.00011905189603567123, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_asset_optimization_efficiency", "lineno": 216, "outcome": "skipped", "keywords": ["test_asset_optimization_efficiency", "skip", "test_backup_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00010967999696731567, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_backup_performance.py', 217, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.00013472000136971474, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_build_feedback_correlation_performance", "lineno": 253, "outcome": "skipped", "keywords": ["test_build_feedback_correlation_performance", "skip", "test_backup_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00011591287329792976, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_backup_performance.py', 254, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.00011787936091423035, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_milestone_snapshot_performance", "lineno": 311, "outcome": "skipped", "keywords": ["test_milestone_snapshot_performance", "skip", "test_backup_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0001271730288863182, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_backup_performance.py', 312, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.00011818995699286461, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_backup_performance.py::test_platform_config_comparison_performance", "lineno": 351, "outcome": "skipped", "keywords": ["test_platform_config_comparison_performance", "skip", "test_backup_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00011860625818371773, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_backup_performance.py', 352, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.000125776045024395, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_playtest_event_recording_performance", "lineno": 38, "outcome": "skipped", "keywords": ["test_playtest_event_recording_performance", "skip", "test_playtest_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00011777272447943687, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_playtest_performance.py', 39, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.00011396408081054688, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_checkpoint_storage_performance", "lineno": 99, "outcome": "skipped", "keywords": ["test_checkpoint_storage_performance", "skip", "test_playtest_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00011017080396413803, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_playtest_performance.py', 100, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.00011132098734378815, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_playtest_analysis_performance", "lineno": 141, "outcome": "skipped", "keywords": ["test_playtest_analysis_performance", "skip", "test_playtest_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00010678730905056, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_playtest_performance.py', 142, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.0012511899694800377, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_high_frequency_event_recording", "lineno": 225, "outcome": "skipped", "keywords": ["test_high_frequency_event_recording", "skip", "test_playtest_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00011679111048579216, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_playtest_performance.py', 226, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.00012989714741706848, "outcome": "passed"}}, {"nodeid": "tests/game_developer/performance/test_playtest_performance.py::test_large_batch_processing", "lineno": 287, "outcome": "skipped", "keywords": ["test_large_batch_processing", "skip", "test_playtest_performance.py", "performance", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.00010903272777795792, "outcome": "skipped", "longrepr": "('/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/tests/game_developer/performance/test_playtest_performance.py', 288, 'Skipped: Need --run-performance option to run')"}, "teardown": {"duration": 0.00011648330837488174, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_save_and_get_config", "lineno": 84, "outcome": "passed", "keywords": ["test_save_and_get_config", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0007100701332092285, "outcome": "passed"}, "call": {"duration": 0.0005228030495345592, "outcome": "passed"}, "teardown": {"duration": 0.00031217699870467186, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_list_platforms", "lineno": 107, "outcome": "passed", "keywords": ["test_list_platforms", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0005555669777095318, "outcome": "passed"}, "call": {"duration": 0.0007850122638046741, "outcome": "passed"}, "teardown": {"duration": 0.0003232918679714203, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_list_versions", "lineno": 124, "outcome": "passed", "keywords": ["test_list_versions", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.000491841696202755, "outcome": "passed"}, "call": {"duration": 0.0008144639432430267, "outcome": "passed"}, "teardown": {"duration": 0.000322089996188879, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_compare_configs_same_platform", "lineno": 150, "outcome": "passed", "keywords": ["test_compare_configs_same_platform", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0004955870099365711, "outcome": "passed"}, "call": {"duration": 0.0009617800824344158, "outcome": "passed"}, "teardown": {"duration": 0.0003009568899869919, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_compare_configs_different_platforms", "lineno": 193, "outcome": "passed", "keywords": ["test_compare_configs_different_platforms", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0005507320165634155, "outcome": "passed"}, "call": {"duration": 0.0009291260503232479, "outcome": "passed"}, "teardown": {"duration": 0.00031818589195609093, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_compare_platforms", "lineno": 236, "outcome": "passed", "keywords": ["test_compare_platforms", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0005405568517744541, "outcome": "passed"}, "call": {"duration": 0.0016689840704202652, "outcome": "passed"}, "teardown": {"duration": 0.00035012001171708107, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_compare_versions", "lineno": 289, "outcome": "passed", "keywords": ["test_compare_versions", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0005075540393590927, "outcome": "passed"}, "call": {"duration": 0.0009460640139877796, "outcome": "passed"}, "teardown": {"duration": 0.0003112358972430229, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_get_version_history", "lineno": 337, "outcome": "passed", "keywords": ["test_get_version_history", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0005048257298767567, "outcome": "passed"}, "call": {"duration": 0.0013207611627876759, "outcome": "passed"}, "teardown": {"duration": 0.00032245274633169174, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_delete_config", "lineno": 375, "outcome": "passed", "keywords": ["test_delete_config", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0005512433126568794, "outcome": "passed"}, "call": {"duration": 0.0012188390828669071, "outcome": "passed"}, "teardown": {"duration": 0.000309026800096035, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_create_config_template", "lineno": 403, "outcome": "passed", "keywords": ["test_create_config_template", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0004321741871535778, "outcome": "passed"}, "call": {"duration": 0.0002009929157793522, "outcome": "passed"}, "teardown": {"duration": 0.0002554580569267273, "outcome": "passed"}}, {"nodeid": "tests/game_developer/platform_config/test_manager.py::test_copy_config", "lineno": 428, "outcome": "passed", "keywords": ["test_copy_config", "test_manager.py", "platform_config", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.000493224710226059, "outcome": "passed"}, "call": {"duration": 0.000849003903567791, "outcome": "passed"}, "teardown": {"duration": 0.0003253938630223274, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_session_summary", "lineno": 155, "outcome": "passed", "keywords": ["test_get_session_summary", "test_analysis.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0014634309336543083, "outcome": "passed"}, "call": {"duration": 0.00025303568691015244, "outcome": "passed"}, "teardown": {"duration": 0.000166366808116436, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_session_summary_not_found", "lineno": 174, "outcome": "passed", "keywords": ["test_get_session_summary_not_found", "test_analysis.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0012032659724354744, "outcome": "passed"}, "call": {"duration": 0.00020317407324910164, "outcome": "passed"}, "teardown": {"duration": 0.00016094371676445007, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_compare_sessions", "lineno": 180, "outcome": "passed", "keywords": ["test_compare_sessions", "test_analysis.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0011316649615764618, "outcome": "passed"}, "call": {"duration": 0.0010122782550752163, "outcome": "passed"}, "teardown": {"duration": 0.00019004009664058685, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_version_statistics", "lineno": 203, "outcome": "passed", "keywords": ["test_get_version_statistics", "test_analysis.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.001248008105903864, "outcome": "passed"}, "call": {"duration": 0.00036339182406663895, "outcome": "passed"}, "teardown": {"duration": 0.00017943698912858963, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_version_statistics_no_sessions", "lineno": 229, "outcome": "passed", "keywords": ["test_get_version_statistics_no_sessions", "test_analysis.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0011435449123382568, "outcome": "passed"}, "call": {"duration": 0.00018205028027296066, "outcome": "passed"}, "teardown": {"duration": 0.00015807943418622017, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_compare_versions", "lineno": 239, "outcome": "passed", "keywords": ["test_compare_versions", "test_analysis.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0013283230364322662, "outcome": "passed"}, "call": {"duration": 0.0006026690825819969, "outcome": "passed"}, "teardown": {"duration": 0.0001926957629621029, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_player_statistics", "lineno": 279, "outcome": "passed", "keywords": ["test_get_player_statistics", "test_analysis.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0012443000450730324, "outcome": "passed"}, "call": {"duration": 0.0003594779409468174, "outcome": "passed"}, "teardown": {"duration": 0.0001852838322520256, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_analysis.py::test_get_player_statistics_no_sessions", "lineno": 313, "outcome": "passed", "keywords": ["test_get_player_statistics_no_sessions", "test_analysis.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0012021171860396862, "outcome": "passed"}, "call": {"duration": 0.00018274737522006035, "outcome": "passed"}, "teardown": {"duration": 0.0001595676876604557, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_start_session", "lineno": 21, "outcome": "passed", "keywords": ["test_start_session", "test_recorder.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.018326909746974707, "outcome": "passed"}, "call": {"duration": 0.004843979142606258, "outcome": "passed"}, "teardown": {"duration": 0.0003309170715510845, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_end_session", "lineno": 43, "outcome": "passed", "keywords": ["test_end_session", "test_recorder.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.017255424056202173, "outcome": "passed"}, "call": {"duration": 0.006979428231716156, "outcome": "passed"}, "teardown": {"duration": 0.00032992567867040634, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_record_event", "lineno": 64, "outcome": "passed", "keywords": ["test_record_event", "test_recorder.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.016642645001411438, "outcome": "passed"}, "call": {"duration": 0.007045934908092022, "outcome": "passed"}, "teardown": {"duration": 0.00034729111939668655, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_update_metrics", "lineno": 101, "outcome": "passed", "keywords": ["test_update_metrics", "test_recorder.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.017635707277804613, "outcome": "passed"}, "call": {"duration": 0.00492804916575551, "outcome": "passed"}, "teardown": {"duration": 0.0003238650970160961, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_save_and_get_checkpoint", "lineno": 126, "outcome": "failed", "keywords": ["test_save_and_get_checkpoint", "test_recorder.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.017632803414016962, "outcome": "passed"}, "call": {"duration": 0.005003277212381363, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/playtest_recorder/test_recorder.py", "lineno": 139, "message": ""}, {"path": "gamevault/playtest_recorder/recorder.py", "lineno": 225, "message": "in save_checkpoint"}, {"path": "gamevault/playtest_recorder/storage.py", "lineno": 363, "message": "in save_checkpoint"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'BINARY_CHECKPOINT_DATA', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nplaytest_recorder = <gamevault.playtest_recorder.recorder.PlaytestRecorder object at 0x7f974c280eb0>\n\n    def test_save_and_get_checkpoint(playtest_recorder):\n        \"\"\"Test saving and retrieving checkpoint data.\"\"\"\n        # Start a session\n        session_id = playtest_recorder.start_session(\n            version_id=\"version123\",\n            player_id=\"player456\"\n        )\n    \n        # Create checkpoint data\n        checkpoint_data = b\"BINARY_CHECKPOINT_DATA\"\n    \n        # Save the checkpoint\n>       checkpoint_id = playtest_recorder.save_checkpoint(\n            session_id,\n            checkpoint_data,\n            \"Level 1 completion\"\n        )\n\ntests/game_developer/playtest_recorder/test_recorder.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/playtest_recorder/recorder.py:225: in save_checkpoint\n    self.storage.save_checkpoint(session_id, checkpoint_id, data, description)\ngamevault/playtest_recorder/storage.py:363: in save_checkpoint\n    compressed_data = compress_data(data)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'BINARY_CHECKPOINT_DATA', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0003365040756762028, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_list_sessions", "lineno": 167, "outcome": "passed", "keywords": ["test_list_sessions", "test_recorder.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.01723159523680806, "outcome": "passed"}, "call": {"duration": 0.030528063885867596, "outcome": "passed"}, "teardown": {"duration": 0.0003522881306707859, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_delete_session", "lineno": 193, "outcome": "passed", "keywords": ["test_delete_session", "test_recorder.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.017674810718744993, "outcome": "passed"}, "call": {"duration": 0.007235162891447544, "outcome": "passed"}, "teardown": {"duration": 0.000316644087433815, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_get_analyzer", "lineno": 216, "outcome": "passed", "keywords": ["test_get_analyzer", "test_recorder.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.018116645980626345, "outcome": "passed"}, "call": {"duration": 0.0001607881858944893, "outcome": "passed"}, "teardown": {"duration": 0.0002904152497649193, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_recorder.py::test_active_session_buffering", "lineno": 223, "outcome": "passed", "keywords": ["test_active_session_buffering", "test_recorder.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.017565338872373104, "outcome": "passed"}, "call": {"duration": 0.005172509700059891, "outcome": "passed"}, "teardown": {"duration": 0.0003322577103972435, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_save_and_get_session", "lineno": 52, "outcome": "passed", "keywords": ["test_save_and_get_session", "test_storage.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.018051038030534983, "outcome": "passed"}, "call": {"duration": 0.0024302289821207523, "outcome": "passed"}, "teardown": {"duration": 0.0003255619667470455, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_delete_session", "lineno": 76, "outcome": "passed", "keywords": ["test_delete_session", "test_storage.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.01760315103456378, "outcome": "passed"}, "call": {"duration": 0.004759537987411022, "outcome": "passed"}, "teardown": {"duration": 0.0003168899565935135, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_list_sessions", "lineno": 96, "outcome": "passed", "keywords": ["test_list_sessions", "test_storage.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.01703488500788808, "outcome": "passed"}, "call": {"duration": 0.008639649022370577, "outcome": "passed"}, "teardown": {"duration": 0.0003352416679263115, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_save_and_get_checkpoint", "lineno": 181, "outcome": "failed", "keywords": ["test_save_and_get_checkpoint", "test_storage.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.01795702800154686, "outcome": "passed"}, "call": {"duration": 0.0027851308695971966, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/playtest_recorder/test_storage.py", "lineno": 190, "message": ""}, {"path": "gamevault/playtest_recorder/storage.py", "lineno": 363, "message": "in save_checkpoint"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nplaytest_storage = <gamevault.playtest_recorder.storage.PlaytestStorage object at 0x7f974c2b1f90>\nsample_session = PlaytestSession(id='session123', version_id='version456', player_id='player789', timestamp=1623456789.0, duration=600.....0, 'health': 75.0, 'enemies_defeated': 5.0, 'collectibles_found': 3.0}, checkpoint_ids=['checkpoint1', 'checkpoint2'])\nsample_checkpoint_data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING'\n\n    def test_save_and_get_checkpoint(playtest_storage, sample_session, sample_checkpoint_data):\n        \"\"\"Test saving and retrieving checkpoint data.\"\"\"\n        # Save the session first\n        playtest_storage.save_session(sample_session)\n    \n        # Save a checkpoint\n        checkpoint_id = \"test_checkpoint\"\n        checkpoint_desc = \"Test checkpoint description\"\n>       playtest_storage.save_checkpoint(\n            sample_session.id,\n            checkpoint_id,\n            sample_checkpoint_data,\n            checkpoint_desc\n        )\n\ntests/game_developer/playtest_recorder/test_storage.py:190: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/playtest_recorder/storage.py:363: in save_checkpoint\n    compressed_data = compress_data(data)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'BINARY_CHECKPOINT_DATA_FOR_TESTING', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.0003585396334528923, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_save_checkpoint_invalid_session", "lineno": 209, "outcome": "passed", "keywords": ["test_save_checkpoint_invalid_session", "test_storage.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.0193161410279572, "outcome": "passed"}, "call": {"duration": 0.0003669089637696743, "outcome": "passed"}, "teardown": {"duration": 0.00031203217804431915, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_list_checkpoints", "lineno": 219, "outcome": "failed", "keywords": ["test_list_checkpoints", "test_storage.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.016397207044065, "outcome": "passed"}, "call": {"duration": 0.002821850124746561, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/compression.py", "lineno": 54, "message": "common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3"}, "traceback": [{"path": "tests/game_developer/playtest_recorder/test_storage.py", "lineno": 228, "message": ""}, {"path": "gamevault/playtest_recorder/storage.py", "lineno": 363, "message": "in save_checkpoint"}, {"path": "gamevault/utils.py", "lineno": 76, "message": "in compress_data"}, {"path": "common/core/compression.py", "lineno": 54, "message": "CompressionError"}], "longrepr": "data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n>               raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\nE               common.core.exceptions.CompressionError: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:51: CompressionError\n\nDuring handling of the above exception, another exception occurred:\n\nplaytest_storage = <gamevault.playtest_recorder.storage.PlaytestStorage object at 0x7f974c337fa0>\nsample_session = PlaytestSession(id='session123', version_id='version456', player_id='player789', timestamp=1623456789.0, duration=600.....0, 'health': 75.0, 'enemies_defeated': 5.0, 'collectibles_found': 3.0}, checkpoint_ids=['checkpoint1', 'checkpoint2'])\nsample_checkpoint_data = b'BINARY_CHECKPOINT_DATA_FOR_TESTING'\n\n    def test_list_checkpoints(playtest_storage, sample_session, sample_checkpoint_data):\n        \"\"\"Test listing checkpoints for a session.\"\"\"\n        # Save the session\n        playtest_storage.save_session(sample_session)\n    \n        # Save multiple checkpoints\n        checkpoint_ids = [\"checkpoint1\", \"checkpoint2\", \"checkpoint3\"]\n        for i, checkpoint_id in enumerate(checkpoint_ids):\n>           playtest_storage.save_checkpoint(\n                sample_session.id,\n                checkpoint_id,\n                sample_checkpoint_data,\n                f\"Checkpoint {i+1}\"\n            )\n\ntests/game_developer/playtest_recorder/test_storage.py:228: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ngamevault/playtest_recorder/storage.py:363: in save_checkpoint\n    compressed_data = compress_data(data)\ngamevault/utils.py:76: in compress_data\n    return common_compress_data(data, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata = b'BINARY_CHECKPOINT_DATA_FOR_TESTING', algorithm = 3, level = 3\n\n    def compress_data(data: bytes, algorithm: str = \"zstd\", level: int = 3) -> bytes:\n        \"\"\"\n        Compress data using specified algorithm.\n    \n        Args:\n            data: Data to compress\n            algorithm: Compression algorithm ('zstd', 'zlib', 'none')\n            level: Compression level (0-22 for zstd, 0-9 for zlib)\n    \n        Returns:\n            Compressed data\n    \n        Raises:\n            CompressionError: If compression fails\n        \"\"\"\n        try:\n            if algorithm == \"none\":\n                return data\n            elif algorithm == \"zstd\":\n                if not HAS_ZSTD:\n                    # Fallback to zlib if zstd not available\n                    return zlib.compress(data, level=min(level, 9))\n    \n                compressor = zstd.ZstdCompressor(level=level)\n                return compressor.compress(data)\n            elif algorithm == \"zlib\":\n                return zlib.compress(data, level=min(level, 9))\n            else:\n                raise CompressionError(f\"Unsupported compression algorithm: {algorithm}\")\n    \n        except Exception as e:\n>           raise CompressionError(f\"Compression failed: {e}\")\nE           common.core.exceptions.CompressionError: Compression failed: Unsupported compression algorithm: 3\n\ncommon/core/compression.py:54: CompressionError"}, "teardown": {"duration": 0.00034295301884412766, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_add_event_to_session", "lineno": 242, "outcome": "passed", "keywords": ["test_add_event_to_session", "test_storage.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.01772858016192913, "outcome": "passed"}, "call": {"duration": 0.005144285038113594, "outcome": "passed"}, "teardown": {"duration": 0.00033597275614738464, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_update_session_metrics", "lineno": 265, "outcome": "passed", "keywords": ["test_update_session_metrics", "test_storage.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.017349975649267435, "outcome": "passed"}, "call": {"duration": 0.004913889802992344, "outcome": "passed"}, "teardown": {"duration": 0.0003314581699669361, "outcome": "passed"}}, {"nodeid": "tests/game_developer/playtest_recorder/test_storage.py::test_mark_session_completed", "lineno": 288, "outcome": "passed", "keywords": ["test_mark_session_completed", "test_storage.py", "playtest_recorder", "game_developer", "tests", "unified", ""], "setup": {"duration": 0.018172672018408775, "outcome": "passed"}, "call": {"duration": 0.009292295668274164, "outcome": "passed"}, "teardown": {"duration": 0.0003570462577044964, "outcome": "passed"}}], "warnings": [{"message": "Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "collect", "filename": "/home/justinchiu_cohere_com/.pyenv/versions/3.10.11/lib/python3.10/site-packages/pydantic/_internal/_config.py", "lineno": 323}, {"message": "Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "collect", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/config.py", "lineno": 44}, {"message": "Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "collect", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/common/core/config.py", "lineno": 53}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}, {"message": "The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/", "category": "PydanticDeprecatedSince20", "when": "runtest", "filename": "/home/justinchiu_cohere_com/minicode/large_repos/incremental_backup_system/unified/creative_vault/backup_engine/incremental_backup.py", "lineno": 123}]}